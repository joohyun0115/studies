Building Secure High-Performance Web Services with OKWS

Abstract
OKWS is a toolkit for building fast and secure Web services. 
It provides Web developers with a small set of tools that has proved powerful
enough to build complex systems with limited effort. 
Despite its emphasis on security, OKWS shows performance improvements compared
to popular systems: when servicing fully dynamic, non-disk-bound database
workloads, OKWS's throughput and responsiveness exceed that of Apache 2 [3],
Flash [23] and Haboob [44]. 
Experience with OKWS in acommercial deployment suggests it can reduce hardware
and system management costs, while providing security guarantees absent in
current systems.

1 Introduction

Most dynamic Web sites today maintain large server-side databases, to which
their users have limited access via HTTP interfaces.
%Most dynamic Web sites today maintain
Keeping this data hidden and correctis critical yet difficult. 
Indeed, headlines are replete with stories of the damage and embarrassment
remote attackers can visit on large Web sites.

Most attacks against Web sites exploit weaknesses inpopular Web servers or bugs
in custom application-level logic. 
In practice, emphasis on rapid deployment and performance often comes at the
expense of security.

Consider the following example: Web servers typically provide Web programmers
with powerful and generic interfaces to underlying databases and rely on
coarse-grained database-level permission systems for access control. 

Web servers also tend to package logically separate programs into one address
space.
If a particular Web site serves its search and new sletter-subscribe features
from the same machine, a bug in the former might allow a malicious remote
client to select all rows from a table of subscribers' email addresses. 
In general, anything from a buffer overrun to an unexpected escape sequence can
expose private data to an attacker. 
Moreover, few practical isolation schemes exist aside from running different
services on different machines. 
As a result, a flaw in one service can ripple through an entire system.

To plug the many security holes that plague existing Web servers, and to limit
the severity of unforeseen problems, we introduce OKWS, the OK Web Server. 
Unlike typical Web servers, OKWS is specialized for dynamiccontent and is not
well-suited to serving files from disk.
It relies on existing Web servers, such as Flash [23] orApache [3], to serve
images and other static content. 
We argue (in Section 5.4) that this separation of static anddynamic content is
natural and, moreover, contributes to security.
What OKWS does provide is a simple, powerful, and secure toolkit for building
dynamic content pages (alsoknown as Web services). OKWS enforces the
naturalprinciple of least privilege [27] so that those aspects ofthe system most
vulnerable to attack are the least useful to attackers.
Further, OKWS separates privileges sothat the different components of the system
distrust each other.
Finally, the system distrusts the Web service developer, presuming him a sloppy
programmer whose errors can cause significant damage.
Though these principles are not novel, Web servers have not generally
incorporated them.
Using OKWS to build Web services, we show that compromises among basic security
principles, perfor-mance, and usability are unnecessary.
To this effect, the next section surveys and categorizes attacks on Webservers,
and Section 3 presents simple design principles that thwart them.
Section 4 discusses OKWS's imple-mentation of these principles, and Section 5
argues that the resulting system is practical for building large systems.
Section 6 discusses the security achieved by the implementation, and Section 7
analyzes its performance,showing that OKWS's specialization for dynamic content
helps it achieve better performance in simulated dynamicworkloads than general
purpose servers.

2 Brief Survey of Web Server Bugs

To justify our approach to dynamic Web server design, we briefly analyze the
weaknesses of popular software packages. 
Our goal is to represent the range of bugs thathave arisen in practice.
Historically, attackers have exploited almost all aspects of conventional Web
servers,from core components and scripting language extensions to the scripts
themselves. 
The conclusion we draw is that a better design as opposed to a more correct
implementation is required to get better security properties.

In our survey, we focus on the Apache [3] server dueto its popularity, but the
types of problems discussed are common to all similar Web servers, including
IBM Web-Sphere [14], Microsoft IIS [19] and Zeus [47].

2.1 Apache Core and Standard Modules

There have been hundreds of major bugs in Apache'score and in its standard
modules. 

They fit into the following categories:
Unintended Data Disclosure. A class of bugs results from Apache delivering files
over HTTP that are supposed to be private. 
For instance, a 2002 bug in Apache's reveals source code of user-written
scripts [42].
A recent discovery of leaked file descriptors allows remote users to access
sensitive log information [7]. 
On Mac OS X operating systems, a local find-by-content indexing scheme creates
a hidden yet world-readable file called.
in each directory indexed.
Versions of Apache released in 2002 expose this file to remote clients [41].
In all cases, attackers can use knowledge about local configuration and
custom-written application code to mount more damaging attacks.

Buffer Overflows and Remote Code Execution.
Buffer overflows in Apache and its many modules are common.
Unchecked boundary conditions found recently in dff and regular expression code
allow local attack [39].

In 2002, a common Apache deployment with OpenSSL had a critical bug in client
key negotiation, allowing remote attackers to execute arbitrary code with the
permissions of the Webserver.
The attacking code downloads, compiles and executes a program that seeks to
infect other machines [36].

There have been less-sophisticated attacks that re-sulted in arbitrary remote
code execution.
Some Windows versions of Apache execute commands in URLs that follow pipe
characters (`ffiffl).
A remote attacker can therefore issue the command of his choosing from an
unmodified Web browser [40].
On MS-DOS-based sys-tems, Apache failed to filter out special device names,
allowing carefully-crafted HTTP POST requests to exe-cute arbitrary code [43].
Other problems have occurred when site developers call Apache's hfl fffl
utilityfrom within CGI scripts to manage HTTP user authentication [6].

Denial of Service Attacks. Aside from TCP/IP-based DoS attacks, Apache has been
vulnerable to a number of application-specific attacks.
Apache versions released in 2003 failed to handle error conditions on certain
"rarely used ports," and would stop servicing incoming connections as a result
[38].
Another 2003 release allowed local configuration errors to result in infinite
redirectionloops [8].
In some versions of Apache, attackers could exhaust Apache's heap simply by
sending a large sequence of linefeed characters [37].

2.2 Scripting Extensions to Apache

Apache's security worsens considerably when compiled with popular modules that
enable dynamically-generated content such as PHP [25].
In the past two years alone, at least 13 critical buffer overruns have been
found in the PHP core, some of which allowed attackers to remotely execute
arbitrary code [9, 28].
In six other cases, faults in PHP allowed attackers to circumvent its
application level chroot-like environment, called "Safe Mode." 
One vulnerability exposed gadm [5].
Another allowed attackers to write PHP scripts to the server and then remotely
execute them;

this bug persisted across multiple releases of PHP intended as fixes [35].

Even if a correct implementation of PHP were possible, it would still provide
Web programmers with ample opportunity to introduce their own vulnerabilities.
A canonical example is that beginning PHP programmers fail to check for
sequences such as ".." in user input and therefore in advertently allow remote
access to sensitive files higher up in the file system hierarchy
(e.g., ../../../\Phi flj/`dfffffi\Delta ). 
Similarly, PHP scripts that embed unescaped user input inside SQL queries
present openings for "SQL Injection." 
If a PHP programmer neglects to escape user input properly, a malicious user can
turn a benign SELECT into a catastrophic DELETE.
The PHP manual does state that PHP scripts might be separated and run as
different users to allow for privilege separation.
In this case, however, PHP could not run as an Apache module, and the system
would require a new PHP process forked for every incoming connection.
This isolation strategy is at odds with performance.

3 Design

If we assume that bugs like the ones discussed above are inevitable when
building a large system, the best remedy is to limit the effectiveness of
attacks when they occur.
This section presents four simple guidelines for protecting sensitive site data
in the worst-case scenario, in which an adversary remotely gains control of a
Web server and can execute arbitrary commands with the Web server's privileges.
We also present OKWS's design, which follows the four security guidelines
without sacrificing performance.
Throughout, we assume a cluster of Web servers and database machines connected
by a fast, firewalled LAN.Site data is cached at the Web servers and
persistently stored on the database machines.
The primary security goals are to prevent intrusion and to prevent unauthorized
access to site data.

3.1 Practical Security Guidelines

(1) Server processes should be chrooted. 
After compromising a server process, most attackers will try to gain control
over the entire server machine, possibly by installing "back doors," learning
local passwords or private keys, or probing local configuration files for
errors. 
At the very least, a compromised Web server should have no access to sensitive
files or directories.
Moreover, an OS-level jail ought to hide all executables from the Web server,
since many privilege escalation attacks require such files (examples include the
ptrace and bindattacks mentioned in [17]).
Privilege escalation is possible without executables but requires OS-level bugs
or race conditions that are typically rarer.

An adversary can still do damage without control ofthe Web server machine. The configuration files, source
files, and binaries that correspond to the currently run-ning Web server contain valuable hints about how to access important data. For instance, PHP scripts often in-clude the username and plaintext password used to gain
access to a MySQL database. OS-enforced policy oughtto hide these files from running Web servers.

(2) Server processes should run as unprivileged users.A compromised process running as a privileged user can
do significant damage even from within a chrooted en-vironment. It might bind to a well-known network port.
It might also interfere with other system processes, espe-cially those associated with the Web server: it can trace
their system calls or send them signals.

(3) Server processes should have the minimal set ofdatabase access privileges necessary to perform their

task. Separate processes should not have access to eachother's databases. Moreover, if a Web server process requires only row-wise access to a table, an adversary whocompromises it should not have the authority to perform
operations over the entire table.

(4) A server architecture should separate independent functionality into independent processes. An adver-sary who compromises a Web server can examine its inmemory data structures, which might contain soft stateused for user session management, or possibly secret tokens that the Web server uses to authenticate itself to itsdatabase. With control of a Web server process, an adversary might hijack an existing database connection orestablish a new one with the authentication tokens it acquired. Though more unlikely, an attacker might alsomonitor and alter network traffic entering and exiting a
compromised server.

The important security principle here is to limit thetypes of data that a single process can access. Site designers should partition their global set of site data intosmall, self-contained subsets, and their Web server ought
to align its process boundaries with this partition.

If a Web server implements principles (1) through (4),and if there are no critical kernel bugs, an attacker cannot

move from vulnerable to secure parts of the system. Byincorporating these principles, a Web server design assumes that processes will be compromised and thereforeprevents uncompromised processes from performing unsafe operations, even when extended by careless Web de-velopers. For example, if a server architecture denies a
successful attacker access to /\Gamma \Delta \Pi /\Sigma \Upsilon ss\Phi \Xi , then a pro-grammer cannot inadvertently expose this file to remote
clients. Similarly, if a successful attacker cannot arbitrar-ily access underlying databases, then even a broken Web
script cannot enable SQL injection attacks.

3.2 OKWS Design
We designed OKWS with these four principles in mind.OKWS provides Web developers with a set of libraries

and helper processes so they can build Web services asindependent, stand-alone processes, isolated almost entirely from the file system. The core libraries providebasic functionality for receiving HTTP requests, accessing data sources, composing an HTML-formatted re-sponse, responding to HTTP requests, and logging the
results to disk. A process called OK launcher daemon,or okld, launches custom-built services and relaunches
them should they crash. A process called OK dispatcher,or okd, routes incoming requests to appropriate Web services. A helper process called pubd provides Web ser-vices with limited read access to configuration files and
HTML template files stored on the local disk. Finally, adedicated logger daemon called

oklogd writes log entriesto disk. Figure 1 summarizes these relationships.

This architecture allows custom-built Web services tomeet our stated design goals:

Figure 1: Block diagram of an OKWS site setup with three Web
services (svc1, svc2, svc3) and two data sources (data1, data2),
one of which (data2) is an OKWS database proxy.

(1) OKWS chroots all services to a remote jail di-rectory. Within the jail, each process has just

enough access privileges to read shared librariesupon startup and to dump core upon abnormal termination. The services otherwise never access thefile system and lack the privileges to do so.

(2) Each service runs as a unique non-privileged user.
(3) OKWS interposes a structured RPC interface be-tween the Web service and the database and uses a

simple authentication mechanism to align the parti-tion among database access methods with the partition among processes.
(4) Each Web service runs as a separate process. Thenext section justifies this choice.

3.3 Process Isolation
Unlike the other three principles, the fourth, of pro-cess isolation, implies a security and performance tradeoff since the most secure option--one Unix process per
external user--would be problematic for performance.OKWS's approach to this tradeoff is to assign one Unix

process per service; we now justify this selection.

Our approach is to view Web server architecture asa dependency graph, in which the nodes represent processes, services, users, and user state. An edge (a, b) de-notes

b's dependence on a, meaning an attacker's abilityto compromise

a implies an ability to compromise b. Thecrucial design decision is thus how to establish dependencies between the more abstract notions of services, usersand user states, and the more concrete notion of a process.

Let the set S represent a Web server's constituent ser-vices, and assume each service accesses a private pool

of data. (Two application-level services that share datawould thus be modelled by a single "service".) A set of
users U interacts with these services, and the interactionbetween user

uj and service si involves a piece of state ti,j.If an attacker can compromise a service

si, he can com-promise state t

i,j for all j; thus (si, ti,j) is a dependency forall j. Compromising state also compromises the corresponding user, so (ti,j, uj) is also a dependency.

Let P = fp1, : : : , pkg be a Web server's pool of pro-cesses. The design decision of how to allocate processes

reduces to where the nodes in P belong on the depen-dency graph. In the Apache architecture [3], each process pi in the process pool can perform the role of anyservice

sj. Thus, dependencies (pi, sj) exist for all j. ForFlash [3], each process in P is associated with a particular

service: for each pi, there exists sj such that (pi, sj) is adependency. The size of the process pool

P is determinedby the number of concurrent active HTTP sessions; each

process pi serves only one of these connections. Java-based systems like the Haboob Server [44] employ only
one process; thus P = fp1g, and dependencies (p1, sj)exist for all

j.

Figures 2(a)-(c) depict graphs of Apache, Flash andHaboob hosting two services for two remote users. Assuming that the "dependence" relationship is transitive,and that an adversary can compromise

p1, the shadednodes in the graph show all other vulnerable entities.

This picture assumes that the process of p1 is equallyvulnerable in the different architectures and that all architectures succeed equally in isolating different processesfrom each other. Neither of these assumptions is entirely
true, and we will return to these issues in Section 6.2.What is clear from these graphs is that in the case of
Flash, a compromise of p1 does not affect states t2,1 andt

2,2. For example, an attacker who gained access to ui'ssearch history (t

1,i) cannot access the contents of his in-box
(t2,i).

A more strict isolation strategy is shown in Figure 2(d).The architecture assigns a process p

i to each user ui. Ifthe attacker is a user u
i, he should only be able to compro(a) Apache (b) Flash (c) Haboob (d) Strict (e) OKWS

Figure 2: Dependency graphs for various Web server architectures.

mise his own process pi, and will not have access to statebelonging to other users

uj. The problem with this ap-proach is that it does not scale well. A Web server would

either need to fork a new process pi for each incomingHTTP request or would have a large pool of mostly idle
processes, one for each currently active user (of whichthere might be tens of thousands).

OKWS does not implement the strict isolation strategybut instead associates a single process with each individual service, shown in Figure 2(e). As a result OKWSachieves the same isolation properties as Flash but with a
process pool whose size is independent of the number ofconcurrent HTTP connections.

4 Implementation
OKWS is a portable, event-based system, written in C++with the SFS toolkit [18]. It has been successfully tested
on Linux and FreeBSD. In OKWS, the different helperprocesses and site-specific services shown in Figure 1
communicate among themselves with SFS's implemen-tation of Sun RPC [32]; they communicate with external Web clients via HTTP. Unlike other event-basedservers [23, 44, 47], OKWS exposes the event architecture to Web developers.

To use OKWS, an administrator installs the helper bi-naries (

okld, okd, pubd and oklogd) to a standard direc-tory such as

/\Gamma \Delta \Theta /\Lambda \Xi \Pi \Sigma \Lambda /\Delta \Upsilon \Phi \Psi , and installs the site-specific services to a runtime jail directory, such as

/\Omega \Sigma \Theta /\Xi fffi\Delta /\Theta \Gamma \Psi . The administrator should allocate twonew UID/GID pairs for okd and oklogd and should also
reserve a contiguous user and group ID space for "anony-mous" services. Finally, administrators can tweak the
master configuration file, /flffi\Pi /\Xi fffi\Delta  \Pi \Xi \Psi c\Phi ffl. Table 1summarizes the runtime configuration of OKWS.

4.1 okld
The root process in the OKWS system is okld--thelauncher daemon. This process normally runs as superuser but can be run as a non-privileged user for testingor in other cases when the Web server need not bind to
a privileged TCP port. When okld starts up, it reads theconfiguration file

/flffi\Pi /\Xi fffi\Delta  \Pi \Xi \Psi c\Phi ffl to determine thelocations of the OKWS helper processes, the anonymous

user ID range, which directories to use as jail directo-ries, and which services to launch. Next, okld launches
the logging daemon (oklogd) and the demultiplexing dae-mon (

okd), and chroots into its runtime jail directory. Itthen launches all site-specific Web services. The steps

for launching a single service are:

1. okld requests a new Unix socket connection fromoklogd.

2. okld opens 2 socket pairs; one for HTTP connectionforwarding, and one for RPC control messages.
3. okld calls c\Xi \Theta ff.
4. In the child address space, okld picks a freshUID/GID pair (

x.x), sets the new process's group listto
fxg and its UID to x. It then changes directoriesinto

/\Pi \Xi \Theta fl\Delta /x.

5. Still in the child address space, okld calls flefl\Pi \Omega fl,launching the Web service. The new Web service

process inherits three file descriptors: one for re-ceiving forwarded HTTP connections, one for receiving RPC control messages, and one for RPC-based request logging. Some configuration parameters in /flffi\Pi /\Xi fffi\Delta  \Pi \Xi \Psi c\Phi ffl are relevant to child ser-vices, and okld passes these to new children via the
command line.

process chroot jail run directory uid gid

okld /\Gamma \Delta \Theta /\Lambda \Xi \Pi \Sigma /\Theta \Upsilon \Phi  / \Theta \Lambda \Lambda r \Pi w\Psi \Psi \Omega 
pubd /\Gamma \Delta \Theta /\Lambda \Xi \Pi \Sigma /wrff\Lambda fi\Sigma  / \Pi \Pi \Pi  \Pi \Pi \Pi 
oklogd /\Gamma \Delta \Theta /\Lambda \Xi \Pi \Sigma /\Omega \Lambda fl / \Lambda \Xi \Omega \Lambda flff \Lambda \Xi \Omega \Lambda flff

okd /\Gamma \Delta \Theta /\Lambda \Xi \Pi \Sigma /\Theta \Upsilon \Phi  / \Lambda \Xi ff \Lambda \Xi ffsvc

1 /\Gamma \Delta \Theta /\Lambda \Xi \Pi \Sigma /\Theta \Upsilon \Phi  /fi\Lambda \Theta \Psi \Sigma /ffiffliiffl ffiffliiffl ffiffliifflsvc
2 /\Gamma \Delta \Theta /\Lambda \Xi \Pi \Sigma /\Theta \Upsilon \Phi  /fi\Lambda \Theta \Psi \Sigma /ffiffliij ffiffliij ffiffliijsvc
3 /\Gamma \Delta \Theta /\Lambda \Xi \Pi \Sigma /\Theta \Upsilon \Phi  /fi\Lambda \Theta \Psi \Sigma /ffifflii` ffifflii` ffifflii`

Table 1: An example confi guration of OKWS. The entries in
the "run directory" column are relative to "chroot jails".

6. In the parent address space, okld sends the serverside of the sockets opened in Step 2 to

okd.

Upon a service's first launch, okld assigns it a group anduser ID chosen arbitrarily from the given range (e.g.,

51001-51080). The service gets those same user andgroup IDs in subsequent launches. It is important that no
two services share a UID or GID, and okld ensures thisinvariant. The service executables themselves are owned
by root, belong to the group with the anonymous GID xchosen in Step 4 and are set to mode

0'^0.These settings allow okld to call
e*e_*e after se,ssaeoebut disallow a service process from changing the mode

of its corresponding binary. okld changes the ownershipsand permissions of service executables at launch if they
are not appropriately set. The directory used in Step 4 isthe only one in the jailed file system to which the child
service can write. If such a directory does not exist orhas the wrong ownership or permissions,

okld creates andconfigures it accordingly.

okld catches So/AEOEO/! when services die. Upon receiv-ing a non-zero exit status,

okld changes the owner andmode of any core files left behind, rendering them inaccessible to other OKWS processes. If a service exits un-cleanly too many times in a given interval,

okld will markit broken and refuse to restart it. Otherwise,

okld restartsdead services following the steps enumerated above.

4.2 okd
The okd process accepts incoming HTTP requests anddemultiplexes them based on the "Request-URI" in their

first lines. For example, the HTTP/1.1 standard [11] de-fines the first line of a GET request as:

AEG" #habs pathi?hqueryi O/""H#^^
Upon receiving such a request, okd looks up a Web ser-vice corresponding to abs path in its dispatch table. If

successful, okd forwards the remote client's file descrip-tor to the requested service. If the lookup is successful
but the service is marked "broken," okd sends an HTTP500 error to the remote client. If the request did not match

a known service, okd returns an HTTP 404 error. In typ-ical settings, a small and fixed number of these services
are available--on the order of 10. The set of availableservices is fixed once

okd reads its configuration file atlaunch time.

Upon startup, okd reads the OKWS configuration file(
#e,_#%&'s _%c(ae)) to construct its dispatch table. Itinherits two file descriptors from okld: one for logging,

and one for RPC control messages. okd then listens onthe RPC channel for okld to send it the server side of
the child services' HTTP and RPC connections (see Sec-tion 4.1, Step 6). okd receives one such pair for each service launched. The HTTP connection is the sink to which
okd sends incoming HTTP requests from external clientsafter successful demultiplexing. Note that okd needs access to oklogd to log Error 404 and Error 500 messages.

okd also plays a role as a control message router forthe child services. In addition to listening for HTTP

connections on port 80, okd also listens for internal re-quests from an administration client. It services the two
RPC calls: REPUB and RELAUNCH. A site maintainershould call the former to "activate" any changes she
makes to HTML templates (see Section 4.4 for more de-tails). Upon receiving a R

EPUB RPC, okd triggers a sim-ple update protocol that propagates updated templates.

A site maintainer should issue a RELAUNCH RPC af-ter updating a service's binary. Upon receiving a R

ELAUNCH RPC, okd simply sends an EOF to the relevantservice on its control socket. When a Web service receives such an EOF, it finishes responding to all pendingHTTP requests, flushes its logs, and then exits cleanly.
The launcher daemon, okld, then catches the correspond-ing

So/AEOEO/! and restarts the service.

4.3 oklogd
All services, along with okd, log their access and error ac-tivity to local files via

oklogd--the logger daemon. Be-cause these processes lack the privileges to write to the

same log file directly, they instead send log updates overa local Unix domain socket. To reduce the total number
of messages, services send log updates in batches. Ser-vices flush their log buffers as they become full and at
regularly-scheduled intervals.

For security, oklogd runs as an unprivileged user inits own

chroot environment. Thus, a compromised okdor Web service cannot maliciously overwrite or truncate

log files; it would only have the ability to fill them with"noise."

4.4 pubd
Dynamic Web pages often contain large sections of staticHTML code. In OKWS, such static blocks are called

HTML "templates"; they are stored as regular files, canbe shared by multiple services and can include each other
in a manner similar to Server Side Includes [4].OKWS services do not read templates directly from
the file system. Rather, upon startup, the publishing dae-mon (

pubd) parses and caches all required templates. Itthen ships parsed representations of the templates over

RPC to other processes that require them. pubd runs asan unprivileged user, relegated to a jail directory that contains only public HTML templates. As a security pre-caution,

pubd never updates the files it serves, and ad-ministrators should set its entire chrooted directory tree

read-only (perhaps, on those platforms that support it, bymounting a read-only

nullfs).

5 OKWS In Practice
Though its design is motivated by security goals, OKWSprovides developers with
a convenient and powerful toolkit.
Our experience suggests that OKWS is suitable for building and maintaining large
commercial systems.

5.1 Web Services
A Web developer creates a new Web service as follows:

1. Extends two OKWS generic classes: one that cor-responds to a long-lived service, and one that corresponds to an individual HTTP request. Implementsthe

i\Gamma i\Delta  method of the former and the p\Theta \Lambda \Xi \Pi \Sigma \Sigma method of the latter.

2. Runs the source file through OKWS's preprocessor,which outputs C++ code.
3. Compiles this C++ code into an executable, and in-stalls it in OKWS's service jail.
4. Adds the new service to /\Pi \Delta \Xi /\Lambda \Upsilon \Phi \Sigma  \Xi \Lambda \Gamma ci\Psi .
5. Restarts OKWS to launch.
The resulting Web service is a single-threaded, event-driven process.

The OKWS core libraries handle the mundane me-chanics of a service's life cycle and its connections to
OKWS helper processes. At the initialization stage,a Web service establishes persistent connections to all
needed databases. The connections last the lifetime ofthe service and are automatically reopened in the case of

abnormal termination. Also at initialization, a Web ser-vice obtains static HTML templates and local configuration parameters from pubd. These data stay in memoryuntil a message from

okd over the RPC control channelsignals that the Web service should refetch. In implementing the i\Gamma i\Delta  method, the Web developer need onlyspecify which database connections, templates and configuration files he requires.

The p\Theta \Lambda \Xi \Pi \Sigma \Sigma  method specifies the actions required forincoming HTTP requests. In formulating replies, a Web

service typically accesses cached soft-state (such as usersession information), database-resident hard state (such
as inbox contents), HTML templates, and configurationparameters. Because a Web service is implemented as a
single-threaded process, it does not require synchroniza-tion mechanisms when accessing these data sources. Its
accesses to a database on behalf of all users are pipelinedthrough a single asynchronous RPC channel. Similarly,
its accesses to cached data are guaranteed to be atomicand can be achieved with simple lightweight data structures, without locking. By comparison, other popularWeb servers require some combination of

mmap'ed files,spin-locks, IPC synchronization, and database connection pooling to achieve similar results.

At present, OKWS requires Web developers to pro-gram in C++, using the same SFS event library that undergirds all OKWS helper processes and core libraries.To simplify memory management, OKWS exposes SFS's
reference-counted garbage collection scheme and high-level string library to the Web programmer. OKWS also
provides a C++ preprocessor that allows for Perl-style"heredocs" and simplified template inclusion. Figure 3
demonstrates these facilities.

5.2 Asynchronous Database Proxies
OKWS provides Web developers with a generic li-brary for translating between asynchronous RPC and

any given blocking client library, in a manner similar toFlash's helper processes [23], and "manual calling automatic" in [1]. OKWS users can thus simply imple-ment database proxies: asynchronous RPC front-ends
to standard databases, such as MySQL [21] or BerkeleyDB [29]. Our libraries provide the illusion of a standard
asynchronous RPC dispatch routine. Internally, theseproxies are multi-threaded and can block; the library handles synchronization and scheduling.

Database proxies employ a small and static number ofworker threads and do not expand their thread pool. The

intent here is simply to overlap requests to the underlyingdata source so that it might overlap its disk accesses and

Figure 3: Fragment of a Web service programmed in OKWS.
The remote client supplies the title and color of the page via
standard CGI-style parameter passing. The runtime templating
system substitutes the user's choice of color for the token OEO/O/!
in the template #%&')*+,-. The variable ,' s.0 +tt12s3
represents a buffer that collects the body of the HTTP response and then is flushed to the client via %o+3o+45. With
the F6-+21OE78 flag set, OKWS fi lters all dangerous metacharacters from the 3919, associative array.

benefit from disk arm scheduling.

Database proxies ought to run on the database ma-chines themselves. Such a configuration allows the site

administrator to "lock down" a socket-based databaseserver, so that only local processes can execute arbitrary
database commands. All other machines in the cluster--such as the Web server machines--only see the structured, and thus restricted, RPC interface exposed by thedatabase proxy.

Finally, database proxies employ a simple mechanismfor authenticating Web services. After a Web service
connects to a database proxy, it supplies a 20-byte au-thentication token in a login message. The database
proxy then grants the Web service permission to accessa set of RPCs based on the supplied authentication token.

To facilitate development of OKWS database prox-ies, we wrapped MySQL's standard C library in an interface more suitable for use with SFS's libraries. Wemodel our MySQL interface after the popular Perl DBI
interface [24] and likewise transparently support bothparsed and prepared SQL styles. Figure 4 shows a simple
database proxy built with this library.

5.3 Real-World Experience
The author and two other programmers built a commer-cial Web site using the OKWS system in six months [22].

We were assisted by two designers who knew little C++but made effective use of the HTML templating system.

The application is Internet dating, and the site features atypical suite of services, including local matching, global
matching, messaging, profile maintenance, site statistics,and picture browsing. Almost a million users have established accounts on the site, and at peak times, thousandsof users maintain active sessions. Our current implementation uses 34 Web services and 12 database proxies.

We have found the system to be usable, stable andwell-performing. In the absence of database bottlenecks or latency from serving advertisements, OKWSfeels very responsive to the end user. Even those
pages that require iterative computations--like matchcomputations--load instantaneously.

Our Web cluster currently consists of four load bal-anced OKWS Web server machines, two read-only cache
servers, and two read-write database servers, all with dualPentium 4 processors. We use multiple OKWS machines
only for redundancy; one machine can handle peak loads(about 200 requests per second) at about 7% CPU utilization, even as it gzips most responses. A previous in-carnation of this Web site required six ModPerl/Apache
servers [20] to accommodate less traffic. It ultimatelywas abandoned due to insufficient software tools and prohibitive hardware and hosting expenses [30].

5.4 Separating Static From Dynamic
OKWS relies on other machines running standard Webservers to distribute static content. This means that all
pages generated by OKWS should have only absolutelinks to external static content (such as images and style
sheets), and OKWS has no reason to support keep-aliveconnections [11]. The servers that host static content for
OKWS, however, can enable HTTP keep-alive as usual.

We note that serving static and dynamic content fromdifferent machines is already a common technique for

performance reasons; administrators choose differenthardware and software configurations for the two types
of workloads. Moreover, static content service does notrequire access to sensitive site data and can therefore happen outside of a firewalled cluster, or perhaps at a differ-ent hosting facility altogether. Indeed, some sites push
static content out to external distribution networks suchas Akamai [2].

In our commercial deployment, we host a cluster ofOKWS and database machines at a local colocation facility; we require hands-on hardware access and a networkconfigured for our application. We serve static content
from leased, dedicated servers at a remote facility wherebandwidth is significantly cheaper.

s\Gamma \Delta \Theta \Lambda \Gamma  \Theta su\Delta \Xi \Pi \Sigma \Delta \Xi \Gamma  -

s\Gamma \Delta \Upsilon \Phi \Psi  \Phi n\Omega ufffiflffiffl
\Upsilon \Phi \Gamma  n\Psi uffl
""ffl

// \Lambda n\Phi  o\Phi ij o\Lambda \Lambda \Theta \Delta  n\Gamma  \Upsilon \Phi \Upsilon \Gamma \Upsilon ni\Upsilon in\Gamma \Upsilon o\Phi  \Gamma \Upsilon \Omega u
q = \Omega jsqimffi`\Delta u`n\Delta u (

"'^*^_* n\Psi ua\Phi n\Omega u F,ssae \Gamma nt Woe^,^ \Upsilon \Sigma =o/"AEffl

\Upsilon \Sigma  = 1ffl // \Psi u\Gamma  IOE f\Delta o\Omega  \Lambda i\Upsilon u\Phi \Gamma 
\Theta su\Delta \Xi \Pi \Sigma \Delta \Xi \Gamma  \Theta ffl

s\Gamma \Omega \Gamma  = qmffiu\Pi u\Lambda \Theta \Gamma u (\Upsilon \Sigma AEffl // \Omega \Upsilon \Psi O/\Gamma  tio\Lambda b
s\Gamma \Omega \Gamma mffifu\Gamma \Lambda O/ (!\Theta #n\Psi ua !\Theta #\Phi n\Omega uAEffl
\Delta u`ij (\Theta AEffl

Figure 4: Example of database proxy code with MySQL wrapper library. In this case, the Web developer is loading SQL
results directly into an RPC XDR structure.

6 Security Discussion
In this section we discuss OKWS's security benefits andshortcomings.

6.1 Security Benefits
(1) The Local Filesystem. An OKWS service has almostno access to the file system when execution reaches

custom code. If compromised, a service has write accessto its coredump directory and can read from OKWS
shared libraries. Otherwise, it cannot access *executables, the binaries of other OKWS services, or
core dumps left behind by crashed OKWS processes. Itcannot overwrite HTTP logs or HTML templates. Other
OKWS services such as oklogd and pubd have moreprivileges, enabling them to write to and read from the
file system, respectively. However, as OKWS matures,these helpers should not present security risks since they
do not run site-specific code.
(2) Other Operating System Privileges. BecauseOKWS runs logically separate processes under different
user IDs, compromised processes (with the exceptionof

okld) do not have the ability to kill or ptrace otherrunning processes. Similarly, no process save for

okldcan bind to privileged ports.

(3) Database Access. As described, all databaseaccess in OKWS is achieved through RPC channels,
using independent authentication mechanisms. As aresult, an attacker who gains control of an OKWS web
service can only interact with the database in a mannerspecified by the RPC protocol declaration; he does
not have generic SQL client access. Note that this isa stronger restriction than simple database permission

systems alone can guarantee. For instance, on PHPsystems, a particular service might only have

SELECTpermissions to a database's
USERS table. But withcontrol of the PHP server, an attacker could still issue

commands like SELECT * FROM USERS. With OKWS,if the RPC protocol restricts access to row-wise queries
and the keyspace of the table is sparse, the attacker hassignificantly more difficulty "mining" the database.1

OKWS's separation of code and privileges further lim-its attacks. If a particular service is compromised, it can
establish a new connection to a remote RPC databaseproxy; however, because the service has no access to
source code, binaries, or ptraces of other services, itknows no authentication tokens aside from its own.

Finally, OKWS database libraries provide runtimechecks to ensure that SQL queries can be prepared only
when a proxy starts up, and that all parameters passed toqueries are appropriately escaped. This check insulates
sloppy programmers from the "SQL injection" attacksmentioned in Section 2.2. We expect future versions of
OKWS to enforce the same invariants at compile time.
(4) Process Isolation and Privilege Separation. OKWSis careful to separate the traditionally "buggy" aspects of
Web servers from the most sensitive areas of the system.In particular, those processes that do the majority of
HTTP parsing (the OKWS services) have the fewestprivileges. By the same logic,

okld, which runs assuperuser, does no message parsing; it responds only

to signals. For the other helper processes, we believethe RPC communication channels to be less error-prone
than standard HTTP messaging and unlikely to allowintruders to traverse process boundaries.

Process isolation also limits the scope of those DoSattacks that exploit bugs in site-specific logic. Since
the operating system sets per-process limits on resourcessuch as file descriptors and memory, DoS vulnerabilities
should not spread across process boundaries. We couldmake stronger DoS guarantees by adapting "defensive
programming" techniques [26]. Qie et al. suggest com-piling rate-control mechanisms into network services, for
dynamic prevention of DoS attacks. Their system isapplicable within OKWS's architecture, which relegates
each service to a single address space. The same cannotbe said for those systems that spread equivalent functionality across multiple address spaces.

6.2 Security Shortcomings
The current implementation of OKWS supports only C++ for service development.
OKWS programmers

Figure 5: PHP version of the null service

should use the provided "safe" strings classes when gen-erating HTML output, and they should use only autogenerated RPC stubs for network communication; how-ever, OKWS does not prohibit programmers from using unsafe programming techniques and can thereforebe made more susceptible to buffer overruns and stacksmashing attacks. Future versions of OKWS might makethese attacks less likely by supporting higher-level programming languages such as Python or Perl.

Another shortcoming of OKWS is that an adversarywho compromises an OKWS service can gain access to

in-memory state belonging to other users. Developersmight protect against this attack by encrypting cache entries with a private key stored in an HTTP cookie on theclient's machine. Encryption cannot protect against an
adversary who can compromise and passively monitor aWeb server.

Finally, independent aspects of the system might bevulnerable due to a common bug in the core libraries.

7 Performance Evaluation
In designing OKWS we decided to limit its process poolto a small and fixed size. In our evaluation, we tested

the hypothesis that this decision has a positive impacton performance, examining OKWS's performance as a
function of the number of active service processes. Wealso present and test the claim that OKWS can achieve
high throughputs relative to other Web servers becauseof its smaller process pool and its specialization for dynamic content.

7.1 Testing Methodology
Performance testing on Web servers usually involves theSPECweb99 benchmark [31], but this benchmark is not

well-suited for dynamic Web servers that disable Keep-Alive connections and redirect to other machines for
static content. We therefore devised a simple benchmark

that better models serving dynamic content in real-worlddeployments, which we call the

null service benchmark.For each of the platforms tested, we implemented a null

service, which takes an integer input from a client, makesa database

SELECT on the basis of that input, and returnsthe result in a short HTML response (see Figure 5). Test

clients make one request per connection: they connect tothe server, supply a randomly chosen query, receive the
server's response, and then disconnect.

7.2 Experimental Setup
All Web servers tested use a large database table filledwith sequential integer keys and their 20-byte SHA-1

hashes [12]. We constrained our client to query only thefirst 1,000,000 rows of this table, so that the database
could store the entire dataset in memory. Our databasewas MySQL version 4.0.16.

All experiments used four FreeBSD 4.8 machines. TheWeb server and database machines were uniprocessor
2.4GHz and 2.6GHz Pentium 4s respectively, each with1GB of RAM. Our two client machines ran Dual 3.0GHz
Pentium 4s with 2GB of RAM. All machines were con-nected via fast Ethernet, and there was no network congestion during our experiments. Ping times between theclients and the Web server measured around 250

1s, andping times between the Web server and database machine

measured about 150 1s.We implemented our test client using the OKWS libraries and the SFS toolkit. There was no resource strainon the client machines during our tests.

7.3 OKWS Process Pool Tests
We experimentally validated OKWS's frugal processallocation strategy by showing that the alternative--

running many processes per service--performs worse.We thus configured OKWS to run a single service as a
variable number of processes, and collected throughputmeasurements (in requests per second) over the different
configurations. The test client was configured to simu-late either 500, 1,000 or 2,000 concurrent remote clients
in the different runs of the experiment.Figure 6 summarizes the results of this experiment as
the number of processes varied between 1 and 450. Weattribute the general decline in performance to increased
context-switching, as shown in Figure 7. In the single-process configuration, the operating system must switch
between the null service and okd, the demultiplexing dae-mon. In this configuration, higher client concurrency implies fewer switches, since both okd and the null servicehave more outstanding requests to service before calling

Figure 6: Throughputs achieved in the process pool test
sleep. This effect quickly disappears as the server dis-tributes requests over more processes. As their numbers
grow, each process has, on average, fewer requests toservice per unit of time, and therefore calls

sleep soonerwithin its CPU slice.

The process pool test supports our hypothesis that aWeb server will consume more

computational resourcesas its process pool grows. Although the experiments

completed without putting memory pressure on the op-erating system, memory is more scarce in real deployments. The null service requires about 1.5MB of corememory, but our experience shows real OKWS service
processes have memory footprints of at least 4MB, andhence we expect memory to limit server pool size. Moreover, in real deployments there is less memory to wasteon code text, since in-memory caches on the Web services are crucial to good site performance and should beallowed to grow as big as possible.

7.4 Web Server Comparison
The other Web servers mentioned in Section 3.3--Haboob, Flash and Apache--are primarily intended for

serving static Web pages. Because we have designedand tuned OKWS for an entirely dynamic workload, we
hypothesize that when servicing such workloads, it per-forms better than its more general-purpose peers. Our
experiments in this section test this hypothesis.

Haboob is Java-based, and we compiled and ran it withFreeBSD's native JDK, version 1.3. We tested Flash

v0.1a, built with F\Gamma  S\Delta \Theta S\Lambda \Xi \Delta  set high so that Flash re-ported an ability to service 5116 simultaneous connections. Also tested was Apache version 2.0.47 compiledwith multi-threading support and running PHP version
4.3.3 as a dynamic shared object. We configured Apacheto handle up to 2000 concurrent connections. We ran
OKWS in its standard configuration, with a one-to-one

Figure 8: Throughputs for the single-service test
correspondence between processes and services.We enabled HTTP access logging on all systems with
the exception of Haboob, which does not support it. Allsystems used persistent database connections.

7.4.1 Single-Service Workload
In the single-service workload, clients with negligible la-tency request a dynamically generated response from the

null service. This test entails the minimal number of ser-vice processes for OKWS and Flash and therefore should
allow them to exhibit maximal throughput. By contrast,Apache and Haboob's process pools do not vary in size
with the number of available services. We examined thethroughput (Figure 8) and responsiveness (Figure 9) of
the four systems as client concurrency increased. Fig-ure 10 shows the cumulative distribution of client latencies when 1,600 were active concurrently.Of the four Web servers tested, Haboob spent the most
CPU time in user mode and performed the slowest. Alikely cause is the sluggishness of Java 1.3's memory
management.When servicing a small number of concurrent clients,
the Flash system outperforms the others; however, its performance does not scale well. We attribute this degrada-tion to Flash's CGI model: because custom-written Flash
helper processes have only one thread of control, eachinstantiation of a helper process can handle only one external client. Thus, Flash requires a separate helper pro-cess for each external client served. At high concurrency
levels, we noted a large number of running processes (onthe order of 2000) and general resource starvation. Flash
also puts additional strain on the database, demandingone active connection per helper--thousands in total. A
database pooling system might mitigate this negative per-formance impact. Flash's results were noisy in general,
and we can best explain the observed non-monotonicityas inconsistent operating system (and database) behavior
under heavy strain.Apache achieves 37% of OKWS's throughput on average. Its process pool is bigger and hence requires morefrequent context switching. When servicing 1,000 concurrent clients, Apache runs around 450 processes, andcontext switches about 7500 times a second. We suspect
that Apache starts queuing requests unfairly above 1,000concurrent connections, as suggested by the plateau in
Figure 9 and the long tail in Figure 10.In our configuration, PHP makes frequent calls to the
sigprocmask system call to serialize database accessesamong kernel threads within a process. In addition,
Apache makes frequent (and unnecessary) file system ac-cesses, which though serviced from the buffer cache still
entail system call overhead. OKWS can achieve fasterperformance because of a smaller process pool and fewer
system calls.

7.4.2 Many-Service Workload
In attempt to model a more realistic workload, we inves-tigated Web servers running more services, serving more

data, as experienced by clients over the WAN. We modi-fied our null services to send out an additional 3000 bytes
of text with every reply (larger responses would have sat-urated the Web server's access link in some cases). We
made 10 uniquely-named copies of the new null service,convincing the Web servers that they were serving 10 distinct services. Finally, our clients were modified to pausean average of 75 ms between establishing a connection
and sending an HTTP request. We ran the experimentfrom 200 to 2000 simultaneous clients, and observed a
graph similar in shape to Figure 8.Achieved throughputs are shown in Table 2 and are
compared to the results observed in the single-serviceworkload. Haboob's performance degrades most notably,
probably because the many-service workload demandsmore memory allocations. Flash's throughput decreases

Figure 10: Client latencies for 1,600 concurrent clients
by 23%. We observed that for this workload, Flash re-quires even more service processes, and at times over
2,500 were running. When we switched from the single-service to the many-service configuration, the number of
OKWS service processes increased from 1 to 10. Theresults from Figure 6 show this change has little impact on throughput. We can better explain OKWS's di-minished performance by arguing that larger HTTP responses result in more data shuffling in user mode andmore pressure on the networking stack in kernel mode.
The same explanation applies for Apache, which experi-enced a similar performance degradation.

8 Related work
Apache's [3] many configuration options and modules al-low Web programmers to extend its functionality with

a variety of different programming languages. How-ever, neither 1.3.x's multi-process architecture nor 2.0.x's
multi-threaded architecture is conducive to process isola-tion. Also, its extensibility and mushrooming code base
make its security properties difficult to reason about.

Haboob Apache Flash OKWS

Table 2: Average throughputs in connections per second

Highly-optimized event-based Web servers such asFlash [23] and Zeus [47] have eclipsed Apache in terms
of performance. While Flash in particular has a history ofoutstanding performance serving static content, our performance studies here indicate that its architecture is lesssuitable for dynamic content. In terms of process isolation, one could most likely implement a similar separa-tion of privileges in Flash as we have done with OKWS.

FastCGI [10] is a standard for implementing long-livedCGI-like helper processes. It allows separation of functionality along process boundaries but neither articulatesa specific security policy nor specifies the mechanics for
maintaining process isolation in the face of partial servercompromise. Also, FastCGI requires the leader process
to relay messages between the Web service and the re-mote client. OKWS passes file descriptors to avoid the
overhead associated with FastCGI's relay technique.

The Haboob server studied here is one of many possi-ble applications built on SEDA, an architecture for eventbased network servers. In particular, SEDA uses serialevent queues to enforce fairness and graceful degradation under heavy load. Larger systems such as Ninja [33]build on SEDA's infrastructure to create clusters of Web
servers with the same appealing properties.

Other work has used the SFS toolkit to build staticWeb Servers and Web proxies [46]. Though the current

OKWS architecture is well-suited for SMP machines, theadoption of libasync-mp would allow for finer-grained
sharing of a Web workload across many CPUs.

OKWS uses events but the same results are possiblewith an appropriate threads library. An expansive body

of literature argues the merits of one scheme over theother, and most recently, Capriccio's authors [34] argue
that threads can achieve the same performance as eventsin the context of Web servers, while providing programmers with a more intuitive interface. Other recent worksuggests that threads and events can coexist [1]. Such
techniques, if applied to OKWS, would simplify stackmanagement for Web developers.

In addition to the PHP [25] scripting language investi-gated here, many other Web development environments
are in widespread use. Zope [48], a Python-based plat-form, has gained popularity due to its modularity and
support for remote collaboration. CSE [13] allows developers to write Web services in C++ and uses some of thesame sandboxing schemes we use here to achieve fault
isolation. In more commercial settings, Java-based sys-tems often favor thin Web servers, pushing more critical
tasks to application servers such as JBoss [15] and IBMWebSphere [14]. Such systems limit a Web server's access to underlying databases in much the same way asOKWS's database proxies. Most Java systems, however,
package all aspects of a system in one address space withmany threads; our model for isolation would not extend
to such a setting. Furthermore, our experimental resultsindicate significant performance advantages of compiled
C++ code over Java systems.

Other work has proposed changes to underlying oper-ating systems to make Web servers fast and more secure.

The Exokernel operating system [16] allows its CheetahWeb server to directly access the TCP/IP stack, in order
to reduce buffer copies allow for more effective caching.The Denali isolation kernel [45] can isolate Web services
by running them on separate virtual machines.

9 Summary and Future Work
OKWS is a toolkit for serving dynamic Web content, andits architecture fits naturally into a compelling security
model. The system's separation of processes providesreasonable assurances that vulnerabilities in one aspect
of the system do not metastasize. The performance re-sults we have seen are encouraging: OKWS derives significant speedups from a small and fixed process pool,lightweight synchronization mechanisms, and avoidance
of unnecessary system calls. In the future, we plan toexperiment with high-level language support and better
resilience to DoS attacks. Independent of future improve-ments, OKWS is stable and practical, and we have used
it to develop a popular commercial product.

Acknowledgments
I am indebted to David Mazi`eres for his help through-out the project, and to my advisor Frans Kaashoek for

help in preparing this paper. Michael Walfish signif-icantly improved this paper's writing and presentation.
My shepherd Eddie Kohler suggested many importantimprovements, Robert Morris and Russ Cox assisted in
debugging, and the anonymous reviewers provided in-sightful comments. I thank the programmers, designers and others at OkCupid.com--Patrick Crosby, JasonYung, Chris Coyne, Christian Rudder and Sam Yagan--
for adopting and improving OKWS, and Jeremy Striblingand Sarah Friedberg for proofreading. This research was

supported in part by the DARPA Composable High As-surance Trusted Systems program (BAA #01-24), under
contract #N66001-01-1-8927.

Availability
OKWS is available under an open source license at

References

[1] A. Adya, J. Howell, M. Theimer, W. J. Bolosky, and J. R.Douceur. Cooperative task management without manual stack

management or, event-driven programming is not the opposite ofthreaded programming. In Proceedings of the 2002 USENIX,
Monterey, CA, June 2002. USENIX.[2] Akamai Technologies, Inc.

RO/ Coordination Center. h\Sigma \Sigma \Upsilon \Phi \Psi \Psi \Omega \Omega \Omega ffi`'\Sigma ffj'^.
[10] Open Market. Fastcgi. h\Sigma \Sigma \Upsilon \Phi \Psi \Psi \Omega \Omega \Omega ff,fic\Sigma i^fflffijffi.[11] R. Fielding, J. Gettys, J. Mogul, H. Frystyk, L. Masinter,

P. Leach, and T. Berners-Lee. Hypertext Transfer Protocol --HTTP/1.1. Internet Network Working Group RFC 2616, 1999.
[12] FIPS 180-1. Secure Hash Standard. U.S. Department ofCommerce/N.I.S.T., National Technical Information Service,

Springfi eld, VA, April 1995.[13] T. Gchwind and B. A. Schmit. CSE --a C++ servlet
environment for high-performance web applications. InProceedings of the FREENIX Track: 2003 USENIX Technical
Conference, San Antonio, TX, 2003. USENIX.[14] IBM corporation. IBM websphere application server.

R. Hunt, D. Mazi`eres, T. Pinckney, R. Grimm, J. Jannotti, andK. Mackenzie. Application performance and flexibility on
exokernel systems. In Proceedings of the 16th ACM Symposiumon Operating Systems Principles, Saint-Malo, France, October
1997. ACM.[17] S. T. King and P. M. Chen. Backtracking intrusions. In
Proceedings of the 19th ACM Symposium on Operating SystemsPrinciples, Bolton Landing, NY, October 2003. ACM.
[18] D. Mazi`eres. A toolkit for user-level fi le systems. InProceedings of the 2001 USENIX. USENIX, June 2001.
[19] Microsoft Corporation. IIS. h\Sigma \Sigma \Upsilon \Phi \Psi \Psi \Omega \Omega \Omega ffffiffli'jcj,\Sigma ffijffi\Psi 

and portable Web server. In Proceedings of the 1999 USENIX,Monterey, CA, June 1999. USENIX.
[24] Perl DBI. h\Sigma \Sigma \Upsilon \Phi \Psi \Psi *offlff\Upsilon `'tffj'^.

[25] PHP: Hypertext processor. h\Sigma \Sigma \Upsilon \Phi \Psi \Psi \Omega \Omega \Omega ff\Upsilon h\Upsilon ff/`\Sigma .[26] X. Qie, R. Pang, and L. Peterson. Defensive programming:

Using an annotation toolkit to build DoS-resistant software. In5th Symposium on Operating Systems Design and
Implementation (OSDI '02), Boston, MA, October 2002.USENIX.
[27] J. H. Saltzer and M. D. Schroeder. The protection of informationin computer systems. In Proceedings of the IEEE, volume 63,

1975.[28] SecurityFocus.

benchmark. h\Sigma \Sigma \Upsilon \Phi \Psi \Psi \Omega \Omega \Omega ffc\Upsilon `ioeoeffj'^\Psi jc^\Psi \Omega `ooeoe\Psi .[32] R. Srinivasan. RPC: Remote procedure call protocol
specifi cation version 2. RFC 1831, Network Working Group,August 1995.
[33] J. R. van Berhen, E. A. Brewer, N. Borisova, M. C.an Matt Welsh, J. MacDonald, J. Lau, S. Gribble, and D. Culler.

Ninja: A framework for network services. In Proceedings of the2002 USENIX, Monterey, CA, June 2002. USENIX.
[34] R. von Behren, J. Condit, F. Zhou, G. C. Necula, and E. Brewer.Capriccio: scalable threads for internet services. In Proceedings

of the 19th ACM Symposium on Operating Systems Principles,Bolton Landing, NY, October 2003. ACM.
[35] Vulnerability CAN-2001-1246. SecurityFocus.

well-conditioned, scalable internet services. In Proceedings ofthe 18th ACM Symposium on Operating Systems Principles,
Chateau Lake Louise, Banff, Canada, October 2001. ACM.[45] A. Whitaker, M. Shaw, and S. D. Gribble. Scale and
performance in the denali isolation kernel. In 5th Symposium onOperating Systems Design and Implementation (OSDI '02),
Boston, MA, October 2002. USENIX.[46] N. Zeldovich, A. Yip, F. Dabek, R. Morris, D. Mazi`eres, and
F. Kaashoek. Multiprocessor support for event-driven programs.In Proceedings of the 2003 USENIX, San Antonio, TX, June
2003. USENIX.[47] Zeus Technology Limited. Zeus Web Server.

Notes

1Similar security properties are possible with a standard Web server
and a database that supports stored procedures, views, and roles.