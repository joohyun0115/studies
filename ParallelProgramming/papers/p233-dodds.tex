A Scalable, Correct Time-Stamped Stack

Abstract
Concurrent data-structures, such as stacks, queues, and de-ques, often
implicitly enforce a total order over elements in their underlying memory
layout. 
However, much of this or-der is unnecessary: linearizability only requires that
elements are ordered if the insert methods ran in sequence. 
We pro-pose a new approach which uses timestamping to avoid unnecessary
ordering. 
Pairs of elements can be left unorderedif their associated insert operations
ran concurrently, and order imposed as necessary at the eventual removal.
We realise our approach in a new non-blocking datastructure, the TS
(timestamped) stack. 
Using the same ap-proach, we can define corresponding queue and deque
datastructures. 
In experiments on x86, the TS stack outperformsand outscales all its
competitors - for example, it outperforms the elimination-backoff stack by
factor of two. 
In our approach, more concurrency translates into less ordering, giving
less-contended removal and thus higher performanceand scalability. 
Despite this, the TS stack is linearizable with respect to stack semantics.
The weak internal ordering in the TS stack presents a challenge when
establishing linearizability: standard tech-niques such as linearization points
work well when there exists a total internal order. 
We present a new stack theo-rem, mechanised in Isabelle, which characterises
the orderings sufficient to establish stack semantics. 
By applying ourstack theorem, we show that the TS stack is indeed linearizable.
Our theorem constitutes a new, generic proof techniquefor concurrent stacks,
and it paves the way for future weakly ordered data-structure designs.

1. Introduction
 
This paper presents a new approach to building orderedconcurrent
data-structures, a realisation of this approach
%This paper presents a new approach to building ordered conccurent
% data-structures, a realisation of this approach
in a high-performance stack, and a new proof technique required to show that
this algorithm is linearizable with respect to sequential stack semantics.
%in a high-performance stack, and a new proof technique required to show that
%this algorithm is linerizable with respect to sequential stack semantics.

Our general approach is aimed at pool-like data-structures, e.g. stacks, queues
and deques. 
%Our general approach is aimed at pool-like data-structures, e.g. stacks, queues
% and deques.

The key idea is for insert into attach timestamps to elements, and for these
timestamps to determine the order in which elements should be removed.
%The key idea is for insert into attach timestamps to elements, and for these
% timestamps to determine the order in which elements should be removed.

This idea can be instantiated as a stack by removing the element with the
youngest timestamp, or as a queue by re-moving the element with the oldest
timestamp. 
%This idea can be instantiated as a stack by removing the element with the
% youngest timestamp, or as a queue by removing the element with the oldest
% timestamp.
Both kinds of operation can be combined to give a deque. 
%Both kinds of operation can be combined to give a deque.
For most of this paper we will focus on the TS (timestamped) stack variant (the
TS queue / deque variants are discussed briefly in. 
%For most of this paper we will focus on the TS (timestamped) stack variant
% the TS queue / deque variants are discussed briefly in.
One might assume that generating a timestamp and adding an element to the
data-structure has to be done together, atomically. 
%One might assume that generating a timestamp and adding an element to the
% data-structure has to be done together, atomically.

This intuition is wrong: linearizabil-it allows concurrent operations to take
effect in any order within method boundaries - only sequential operations have
to keep their order [14]. 
%This intuition is wrong: linearizabil-it allow concurrent operations to take
% effect in any order within method boundaries 
Therefore we need only order inserted elements if the methods inserting them
execute sequentially. 
%Therefore we need only order inserted elements if the methods inserting them
% execute sequentially.
We exploit this fact by splitting timestamp generation from element insertion,
and by allowing unordered timestamps. 
%We exploit this fact by splitting timestamp generation from element insertion,
% and by allowing unordered timestamps.
Two elements may be timestamped in a different order than they were inserted,
or they may be unordered, but only when the surrounding methods overlap, meaning
the elements could legitimately be removed in either order.
%Two elements may be timestamped in a different order than they were inserted,
% or they may be unordered, but only when the surrounding methods overlap,
% meaning the elements could legitimately be removed in either order.
The only constraint is that elements of sequentially executed insert operations
receive ordered timestamps.
%The only constraint is that elements of sequentially executed insert operations
% receive ordered timestamps.
By separating timestamp creation from adding the element to the data-structure,
our insert method can avoids twoexpensive synchronisation patterns -
atomic-write-afterread (AWAR) and read-after-write (RAW). 
%By separating timestamp creation from adding the element to the data-structure,
% ourt insert method can avoids two expensive synchronisation patterns -
% atomic-write-after read (AWAR) and read-after-write (RAW).
We take the sepatterns from [2], and refer to them collectively as strong
synchronisation. 
%We take the sepatterns from, and refer to them collectively as strong
% synchronisation.
Timestamping can be done by a stutteringcounter or a hardware instruction like
the x86 RDTSCP in struction, neither of which require strong synchronization.
%Timestamping can be done by a stuttering counter or a hardware instruction like
% the x86 RDTSCP
%struction, neither of which require strong sysnchronization.

Timestamped elements can be stored in per-thread single producer
multiple-consumer pools.
%Timestamped elements can be stored in per-thread single producer 
% multiple-consumer pools.

Such pools also do not require strong synchronization in the insert operation.
%Such pools also do not require strong synchronization in the insert operation.
Thus stack insertion avoids strong synchronization, radically re-ducing its cost.
%Thus stack insertion avoids strong synchronization, radically reducing its
% cost.
The lack of synchronization in the insert operation comesat the cost of
contention in the remove operation. 
%The lack of synchronization in the insert operation comes at the cost of
% contention in the remove operation.
Indeed, [2] proves that stacks, queues, and deques cannot be implemented
without some strong synchronisation. 
%Indedd, proved that stacks, queues, and deques cannot be implemented without
% some strong synchronisation.

Perhaps surprisingly, this problem can be mitigated by reducing the ordering
between timestamps: intuitively, less ordering results in more opportunities
for parallel removal, and thus less contention. 
%Perhaps surprisingly, this problem can be mitigated by reducing the ordering
% between timestamps: intuitively, less ordering results in more ooprtunities
% for parallel removal, and thus less contention.
To weaken the element order, we associate elements with intervals represented
by pairs of timestamps.
%To weaken the element order, we associate elements with intervals 
Interval timestamps allow our TS stack to achieve performance and scalability
better than state-of-the-art concur-rent stacks. 
For example, we believe the elimination-backoff stack is the current world
leader; in our experiments on x86,the TS stack outperforms it by a factor of
two.

Establishing correctness for the TS stack presents a chal-lenge for existing proof methods. The standard approach
would be to locate linearization points, syntactic points inthe code which fix the order that methods take effect. This
simply does not work for timestamped structures, becausethe order of overlapping push operations is fixed by the order of future pop operations. In the absence of pop opera-tions, elements can remain entirely unordered. We solve this
with a new theorem, mechanised in the Isabelle proof assis-tant, which builds on Henzinger et al.'s aspect-oriented technique [12]. Rather than a total order, we need only generatean order from push to pop operations, and vice versa, which
avoids certain violations. This order can be generated fromsyntactic points in the TS stack code, allowing us to show
that it is correct. Our stack theorem is generic, not tied tothe TS stack. By generalising away from linearization points,
it paves the way for future concurrent data-structures whichweaken internal ordering.

Contribution. To summarise, our contributions are:

* A new class of data-structure based on timestamping,realised as a stack, queue, and deque.

* A new optimisation strategy, interval timestamping,which exploits the weak ordering permitted by timestamped data-structures.*
A new proof technique for establishing the linearizabilityof concurrent stacks, and a mechanisation of the core

theorem in Isabelle.*
A detailed application of this proof technique to showthat the TS stack is linearizable with respect to its

sequential specification.*
An experimental evaluation showing our TS stack out-performs the best existing concurrent stacks.

Artifacts. We have produced two research artifacts:

* The TS stack itself, implemented in C, along with queueand deque variants, and benchmark code used to test it.

* The Isabelle mechanisation of our stack theorem.
Both artifacts are included with the supplementary materialon the ACM digital library, and are also available from the

TS stack webpage:

http://scal.cs.uni-salzburg.at/tsstack/

!"#$%&'(
!" # $ %&'()( * + ,

---

%./ )(0% )(0% )(0% )(0%
!1 2 $%./ )(0%

!, & ! 3 1%./ )(0% )(0%

!) %./

- - -

4/5..64

Figure 2: The TS stack data-structure.
Paper structure. $2 describes the key ideas behind theTS stack, then in $3 we describe the algorithm in detail. In

$4 we describe our proof technique, while in $5 we use it toestablish that the TS stack is linearizable. In $6 we discuss
our experiments. $7 discusses TS queue and deque variants.$8 surveys the related work. $9 concludes.

Longer proofs and other auxiliary material are includedin supplementary appendices, available on the ACM digital
library. Appendix A discusses the Isabelle proof of our corestack theorem. Appendix B gives further details about our
TS stack linearizability proof. Appendix C gives a proof ofcorrectness for our intermediate TS buffer data-structure.

2. Key Ideas
Algorithm structure. The TS stack marks elements withtimestamps recording the order they were pushed. Elements are popped according to this timestamp order. Fig-ure 2 shows the stack's internal structure. Each thread

T1-
Tn which is accessing the stack has an associated single-producer multi-consumer pool, implemented as a linked list

(we call these SP pools). These are linked from a commonarray spPools. Every element on the stack is stored in the
SP pool of the thread that pushed it.Pushing to the TS stack involves (1) adding a node to
the head of the thread's SP pool, (2) generating a newtimestamp, and (3) attaching the timestamp to the node.
Thus un-timestamped nodes are visible to other threads -we write these in Figure 2 as the maximal value, !. As nodes
are only added by one thread to each SP pool, elementsin a single pool are totally ordered by timestamp, and no
synchronisation is needed when pushing.Popping from the TS stack involves (1) searching all the
SP pools for an element with a maximal timestamp, and(2) attempting to remove it. This process repeats until an
element is removed successfully. As each SP pool is ordered,searching only requires reading the head of each pool in turn.
Timestamps in different pools may be mutually unordered- for example when two timestamps are equal. Thus more
than one element may be maximal, and in this case, eithercan be chosen. To remove a node, the thread writes to a flag
in the node marking it as taken. Multiple threads may tryto remove the same node, so an atomic compare-and-swap
(CAS) instruction ensures at most one thread succeeds.Accessing the heads of multiple per-thread pools imposes
a cost through cache contention. However, our experimentsshow that this can be less expensive than contention on
a single location with an opportunistic compare-and-swapapproach. In our experiments, we mitigate contention and
thereby improve performance by introducing a small NOP

234

delay to the pop search loop. However, even without thisoptimisation, the TS stack outperforms the EB stack by a
factor of two.We have experimented with various implementations for
timestamping itself. Most straightforwardly, we can use astrongly-synchronised fetch-and-increment counter. We can
avoid unnecessary increments by using a compare-and-swapto detect when the counter has already been incremented.
We can avoid strong synchronisation entirely by using avector of thread-local counters, meaning the counter may
stutter (many elements get the same timestamp). We canalso use a hardware timestamping operation - for example the RDTSCP instruction which is available on all modernx86 hardware. Our benchmarks show that hardware timestamping provides the best push performance. However, thepicture is more complicated in the presence of optimisation.
See $6 for our experiments.
Optimisations. Timestamping enables several optimisa-tions of the TS stack, most importantly elimination (a standard strategy in the literature), and interval timestamping(a contribution of this paper).

In a stack, a concurrent push and pop can always soundlyeliminate each other, irrespective of the state of the stack [9].
Therefore a thread can remove any concurrently insertedelement, not just the stack top. Unlike [9], our mechanism for
detecting elimination exploits the existence of timestamps.We read the current time at the start of a pop; any element
with a later timestamp has been pushed during the currentpop, and can be eliminated.

Surprisingly, it is not optimal to insert elements asquickly as possible. The reason is that removal is quicker
when there are many unordered maximal elements, reduc-ing contention and avoiding failed CASes. To exploit this,
we define timestamps as intervals, represented by a pairof start and end times. Overlapping interval timestamps
are considered unordered, and thus there can be many topelements in the stack. To implement this, the algorithm includes a delay for a predetermined interval after generatinga start timestamp, then generates an end timestamp.

Pausing allows us to trade off the performance of pushand pop: an increasing delay in insertion can reduce the
number of retries in pop (for evidence see $6.2). Thoughpausing may appear as an unnecessary overhead to a push,
our experiments show that optimal delay times (4 us - 8 us)are actually shorter than e.g. an atomic fetch-and-inc on
a contended memory location. By weakening the order ofstored elements, interval timestamping can substantially
increase overall throughput and decrease the latency of pops.Similarly, although interval timestamping increases the
non-determinism of removal (i.e. the variance in the or-der in which pushed elements are popped), this need not
translate into greater overall non-determinism comparedto other high-performance stacks. A major source of nondeterminism in existing concurrent data-structures is in factcontention [7]. While interval timestamping increases the potential for non-determinism in one respect, it decreases it inanother.

Performance vs. Elimination-Backoff stack. To thebest of our knowledge the Elimination-Backoff (EB) stack [9]
is the fastest stack previously proposed. In our experiments($6.1) the TS stack configured with elimination and interval
timestamping outperforms the EB stack by a factor of two.Several design decisions contribute to this success. The lack
of insert-contention and mitigation of contention in the

!"#$%&'
!"#$%('

!)!%'\Gamma &
!)!%'\Gamma (
*+#

,&-
*.

,&-

./0

!.1\Delta 
2.&+#*2*,/1*.
!.1\Delta 
2.&+#*2*,/1*.

Figure 3: Non-LIFO behaviour forbidden by stack theorem.
remove makes our stack fast even without elimination. Also,timestamping allows us to integrate elimination into normal
stack code, rather than in separate back-off code.
Algorithm correctness. Intuitively, the TS stack is cor-rect because any two push operations that run sequentially

receive ordered timestamps, and are therefore removed inLIFO order. Elements arising from concurrent push operations may recieve unordered timestamps, and may be re-moved in either order, but this does not affect correctness.

To formally prove that a stack is correct, i.e. linearizablewith respect to stack semantics, we need to show that for
any execution there exists a total linearization order. How-ever, proving this directly is challenging, because the order
between parallel push operations can be fixed by the orderon later pop operations, while the order between parallel
pop operations can likewise be fixed by earlier pushes.Instead, we use a new stack theorem which removes the
need to find a total linearization order. Intuitively, ourtheorem requires that if two elements are on the stack, then
the younger element is popped first (i.e. LIFO ordering).It is important that all operations take a consistent view
on which elements are on the stack. To express this, ourstack theorem require a relation which states whether a push
takes logical effect before or after a pop. We call this ir, for`insert-remove'. The ir relation is the crux of the linearization
order: surprisingly, our theorem shows that it is the onlypart that matters. Thus, the stack theorem relieves us of
the need to resolve problematic ordering between parallelpush or parallel pop operations.

The stack theorem also uses two other relations: prece-dence, pr, which relates methods that run in sequence; and
value, val, which relates a push to the pop removing the as-sociated value. Loosely, the theorem has the following form:

If for every execution there exist ir, pr, val relationsthat are order-correct, then the algorithm is linearizable with respect to sequential stack semantics.1
Order-correctness rules out non-LIFO behaviour. Intu-itively, the situation shown in Figure 3 is forbidden: if

push(a) and push(b) are ordered, and push(b) is relatedto pop()!

a in ir, then the two pops cannot also be orderedpop()!
a before pop()!b - this would violate LIFO ordering.As pr and val can easily be extracted from an execution,

establishing linearizability amounts to showing the existenceof a consistent ir. This is analogous to finding the linearization order, but ir can be constructed much more easily forthe TS stack. We use a modified version of the linearization
point method, but rather than a single order, we identifytwo and combine them to build ir.

* vis (for `visibility'). A push(a) and pop are ordered by visif the value

a inserted by push was in a SP pool whenthe pop started, and so could have been visible to it.

1 Additionally, the full theorem requires the algorithm is linearizable with respect to sequential set semantics. This guaranteesnon-LIFO properties such as absence of duplication.

235

* rr (for `remove-remove'). Two operations pop()!a andpop()!

b are ordered in rr if elements a and b are removedin order from the underlying SP pools.

Building ir is more than just merging these two relationsbecause they may contradict one another. Instead, ir is built
by taking vis as a core, and using rr to correct cases thatcontradict LIFO order. Our proof of correctness ($5) shows
that this is always possible, which establishes that the TSstack is linearizable.

3. The TS Stack in Detail
We now present our TS stack algorithm in detail. Listing 1shows the TS stack code. This code manages the collection

of thread-specific SP pools linked from the array spPools.We factor the SP pool out as a separate data-structure
supporting the following operations:

* insert - insert an element without attaching a time-stamp, and return a reference to the new node.

* getYoungest - return a reference to the node in thepool with the youngest timestamp, together with the top

pointer of the pool.*
remove - tries to remove the given node from the pool.Return true and the element of the node or false and

NULL depending whether it succeeds.
We describe our implementation of the SP pool in $3.1. List-ing 1 also assumes the timestamping function newTimestamp

- various implementations are discussed in $3.2.We can now describe Listing 1. To push an element, the
TS stack inserts an un-timestamped element into the currentthread's pool (line 13), generates a fresh timestamp (line 14),
and sets the new element's timestamp (line 15).A pop iteratively scans over all SP pools (line 35-54)
and searches for the node with the youngest timestampin all SP pools (line 48-53). The binary operator

<TS istimestamp comparison. This is just integer comparison for

non-interval timestamps - see $3.2. If removing the identifiednode succeeds (line 63) then its element is returned (line 26).
Otherwise the iteration restarts.For simplicity, in Listing 1 threads are associated statically with slots in the array spPools. To support a dynamicnumber of threads, this array can be replaced by a linked
list for iteration in pop, and by a hashtable or thread-localstorage for fast access in push.

Elimination and emptiness checking. Code in gray inListing 1 handles elimination and emptiness checking.

Elimination [9] is an essential optimisation in making ourstack efficient. It is permitted whenever a push and pop execute concurrently. To detect opportunities for elimination,a pop reads the current time when it starts (line 20). When
searching through the SP pools, any element with a latertimestamp must have been pushed during the current pop,
and can be eliminated immediately (lines 46-47).To check whether the stack is empty, we reuse an approach from [8]. When scanning the SP pools, if a pool in-dicates that it is empty, then its top pointer is recorded
(lines 40-43). If no candidate for removal is found then theSP pools are scanned again to check whether their top pointers have changed (lines 56-60). If not, the pools must havebeen empty between the first and second scan. The linearizability of this emptiness check has been proved in [8].

Listing 1: TS stack algorithm. The SP pool is defined inListing 2 and described in $3.1, timestamps are discussed
in $3.2. The gray highlighted code deals with the emptinesscheck and elimination.

1 TSStack {2 Node {
3 Element element ,4 Timestamp timestamp ,
5 Node next ,6 Bool taken
7 };8
9 SPPool [ maxThreads ] spPools ;10
11 v oid push ( Element element ){12 SPPool pool = spPools [ threadID ];
13 Node node = pool . insert ( element );14 Timestamp timestamp = newTimestamp ();
15 node . timestamp = timestamp ;16 }
1718 Element pop (){
19 // Elimination20 Timestamp startTime = newTimestamp ();
21 Bool success ;22 Element element ;
23 do{24 <success , element >= tryRem ( startTime );
25 } w h i l e (! success );26 r e t u r n element ;
27 }28
29 <Bool , Element > tryRem ( Timestamp startTime ){30 Node youngest = NULL ;
31 Timestamp timestamp = -1;32 SPPool pool ;
33 Node top ;34 Node [ maxThreads ] empty ;
35 f o r each ( SPPool current in spPools ){36 Node node ;
37 Node poolTop ;38 <node , poolTop >= current . getYoungest ();
39 // Emptiness check40 i f ( node == NULL ){
41 empty [ current .ID ]= poolTop ;42 c o n t i n u e ;
43 }44 Timestamp nodeTimestamp = node . timestamp ;
45 // Elimination46 i f ( startTime

<TS nodeTimestamp )47 r e t u r n current . remove ( poolTop , node );

48 i f ( timestamp <TS nodeTimestamp ){49 youngest = node ;
50 timestamp = nodeTimestamp ;51 pool = current ;
52 top = poolTop ;53 }
54 }55

// Emptiness check56 i f ( youngest == NULL ){

57 f o r each ( SPPool current in spPools ){58 i f ( current . top != empty [ current .ID ])
59 r e t u r n <false ,NULL >;60 }
61 r e t u r n <true ,EMPTY >;62 }
63 r e t u r n pool . remove (top , youngest );64 }
65 }

236

Listing 2: SP pool algorithm. The gray highlighted codedeals with the unlinking of taken nodes.
66 SPPool {67 Node top ;
68 Int ID; // The ID of the owner thread.69
70 init (){71 Node sentinel =
72 createNode ( element =NULL , taken = true );73 sentinel . next = sentinel ;
74 top = sentinel ;75 }
7677 Node insert ( Element element ){
78 Node newNode =79 createNode ( element = element , taken = false );
80 newNode . next = top ;81 top = newNode ;
82 Node next = newNode . next ; // Unlinking83 w h i l e (next -> next != next && next . taken )
84 next = next -> next ;85 newNode . next = next ;
86 r e t u r n newNode ;87 }
8889 <Node ,Node > getYoungest (){
90 Node oldTop = top ;91 Node result = oldTop ;
92 w h i l e ( true ){93 i f (! result . taken )
94 r e t u r n <result , oldTop >;95 e l s e i f ( result . next == result )
96 r e t u r n <NULL , oldTop >;97 result = result . next ;
98 }99 }
100101 <Bool , Element > remove ( Node oldTop , Node node ){
102 i f ( CAS ( node .taken , false , true )){103 CAS (top , oldTop , node );

// Unlinking104 // Unlink nodes before node in the list.

105 i f ( oldTop != node )106 oldTop . next = node ;
107 // Unlink nodes after node in the list.108 Node next = node . next ;
109 w h i l e (next -> next != next && next . taken )110 next =next -> next ;
111 node . next = next ;112 r e t u r n <true , node . element >;
113 }114 r e t u r n <false ,NULL >;
115 }116 }

3.1 SP Pool
The SP pool (Listing 2) is a singly linked list of nodesaccessed by a top pointer. A node consists of a next pointer

for the linked list, the element it stores, the timestampassigned to the element, and a taken flag. The singly linked
list is closed at its end by a sentinel node pointing to itself(line 73). Initially the list contains only the sentinel node.
The taken flag of the sentinel is set to true indicatingthat the sentinel does not contain an element. The top
pointer is annotated with an ABA-counter to avoid theABA-problem [13].

Elements are inserted into the SP pool by adding a newnode (line 78) at the head of the linked list (line 80-81).

To remove an element the taken flag of its node is setatomically with a CAS instruction (line 102). getYoungest
iterates over the list (line 90-98) and returns the first nodewhich is not marked as taken (line 94). If no such node is
found, getYoungest returns <NULL,oldTop> (line 96).
Unlinking taken nodes. Nodes marked as taken are con-sidered removed from the SP pool and are therefore ignored

by getYoungest and remove. However, to reclaim memoryand to reduce the overhead of iterating over taken nodes,
nodes marked as taken are eventually unlinked either ininsert (line 82-85) or in remove (line 103-111).

To unlink we redirect the next pointer from a node ato a node

b previously connected by a sequence of takennodes (line 85, line 106, and line 111). In insert the nodes

between the new node and the next un-taken node areunlinked, and in remove the nodes between the old top node
and the removed node, and between the removed node andthe next un-taken node are unlinked. Additionally remove
tries to unlink all nodes between top and the removed node(line 103). By using CAS, we guarantee that no new node has
been inserted between the top and the removed node.
3.2 Timestamping Algorithms
TS-atomic: This algorithm takes a timestamp from aglobal counter using an atomic fetch-and-increment instruction. Such instructions are available on most modern pro-cessors - for example the LOCK XADD instruction on x86.

TS-hardware: This algorithm uses the x86 RDTSCP in-struction [16] to read the current value of the TSC register. The TSC register counts the number of processor cyclessince the last reset.

TSC was not originally intended for timestamping, soan obvious concern is that it might not be synchronised
across cores. In this case, relaxed-memory effects could leadto stack-order violations. We believe this is not a problem
for modern CPUs. Ruan et al. [20] have tested RDTSCP onvarious x86 systems as part of their transactional memory
system. Our understanding of [20] and the Intel x86 archi-tecture guide [16] is that RDTSCP should provide sufficient
synchronisation on recent multi-core and multi-socket ma-chines. We have also observed no violations of stack semantics in our experiments across different machines. Aside fromRDTSCP, we use C11 sequentially consistent atomics throughout, forbidding all other relaxed behaviours.However, we have anecdotal reports that RDTSCP is not
synchronised on older x86 systems. Furthermore, memoryorder guarantees offered by multi-processors are often underspecified and inaccurately documented - see e.g. Sewell et.al.'s work on a formalized x86 model [21] (which does not
cover RDTSCP). Implementors should test RDTSCP thoroughlybefore using it to generate timestamps on substantially
different hardware. We hope the TS stack will motivatefurther research into TSC, RDTSCP, and hardware timestamp
generation more generally.
TS-stutter: This algorithm uses thread-local counterswhich are synchronized by Lamport's algorithm [17]. To

generate a new timestamp a thread first reads the values ofall thread-local counters. It then takes the maximum value,
increments it by one, stores it in its thread-local counter,and returns the stored value as the new timestamp. Note
that the TS-stutter algorithm does not require strong syn-chronization. TS-stutter timestamping may return the same
timestamp multiple times, but only if these timestamps weregenerated concurrently.

237

Listing 3: TS-CAS algorithm. The gray highlighted code isan optimisation to avoid unnecessary CAS.
117 TS_cas {118 i n t counter =1;
119120 Timestamp newTimestamp (){
121 i n t timestamp = counter ;122 pause (); // delay optimisation .
123 i n t timestamp2 = counter ;124 i f ( timestamp != timestamp2 )
125 r e t u r n [ timestamp , timestamp2 -1];126 i f ( CAS ( counter , timestamp , timestamp +1))
127 r e t u r n [ timestamp , timestamp ];128 r e t u r n [ timestamp , counter -1];
129 }130 }

TS-interval: This algorithm does not return one time-stamp value, but rather an interval consisting of a pair of
timestamps generated by one of the algorithms above. Let[

a, b] and [c, d] be two such interval timestamps. They areordered [

a, b] <TS [c, d] if and only if b < c. That is, if thetwo intervals overlap, the timestamps are unordered. The

TS-interval algorithm is correct because for any two intervaltimestamps [

a, b] and [c, d], if these intervals are generatedsequentially, then

b is generated before c and therefore b < c,as discussed above.

In our experiments we use the TS-hardware algorithm(i.e. the x86 RDTSCP instruction) to generate the start and
end of the interval, because it is faster than TS-atomic andTS-stutter. Adding a delay between the generation of the
two timestamps increases the size of the interval, allowingmore timestamps to overlap and thereby reducing contention
during element removal. The effect of adding a delay onoverall performance is analyzed in Section 6.2.

TS-CAS: This algorithm is an optimisation of TS-atomiccombined with interval timestamps. It exploits the insight
that the shared counter needs only be incremented by somethread, not necessarily the current thread. In a highly concurrent situation, many threads using TS-atomic will incre-ment the counter unnecessarily. The TS-CAS algorithm instead uses CAS failure to detect when the counter has beenincremented. CAS failure without retrying is comparatively
inexpensive, so this scheme is fast despite using strong syn-chronisation.

Source-code for TS-CAS is given in Listing 3. The al-gorithm begins by reading the counter value (line 121). If
the CAS in line 126 succeeds, then the timestamp takes thecounter's original value as its start and end (line 127). If
the CAS fails, then another concurrent call must have incre-mented the counter, and TS-CAS does not have to. Instead
it returns an interval starting at the original counter valueand ending at the new value minus one (line 128). This interval will overlap with concurrent calls to newTimestamp,but will not overlap with any intervals created later.

Similar to TS-interval, adding a small delay betweenreading the counter value and attempting the CAS can improve performance. Here this not only increases the numberof overlapping intervals, but also reduces contention on the
global counter. Contention is reduced further by line 123-125, a standard CAS optimisation. If the value of counter
changed during the delay, then the CAS in line 126 is guar-anteed to fail. Instead of executing the CAS we can immediately return an interval timestamp. Our experimentsshow that in high-contention scenarios the performance of
TS-CAS with a delay is up to 3x faster than without a delay.

4. Correctness Theorem for Stacks
Linearizability [14] is the de facto standard correctness con-dition for concurrent algorithms.2 It ensures that every behaviour observed by an algorithm's calling context could alsohave been produced by a sequential (i.e. atomic) version of
the same algorithm. We call the ideal sequential version ofthe algorithm the specification, e.g. below we define a sequential stack specification.Interactions between the algorithm and calling context
in a given execution are expressed as a history. Note thatour formulation is specialised to pool-like data-structures,
because the val relation embeds the connection betweenan operation which inserts a value, and the operation that
receives it (e.g. a push and corresponding pop).
Definition 1. A history H is a tuple "A, pr, val# where Ais a finite set of operations (for example, push(5)), and

pr, val $ A * A are the precedence and value relations,respectively. A history is sequential if pr is a total order.

A history is extracted from a trace, T , the interleavedsequence of events that took place during an execution of
the algorithm. To extract the history, we first generate theset A of executed operations in the trace (as is standard
in linearizability, assume that all calls have correspondingreturns). A pair (

x, y) is in pr if the return event of operation
x is ordered before the call event of y in T . A pair (x, y) isin val if

x is an insert, y a remove, and the value inserted by
x was removed by y. Note that we assume that values areunique.

Linearizability requires that algorithms only interactwith their calling context through call and return events.
Therefore, a history captures all interactions between algo-rithm and context. We thus define a data-structure specification as just a set of histories (e.g. Stack is the set ofhistories produced by an ideal sequential stack). Linearizability is defined by relating implementation and specifica-tion histories.

Definition 2. A history "A, pr, val# is linearizable withrespect to some specification S if there exists a linearization
order prT such that pr $ prT , and "A, prT , val# & S.An implementation

C is linearizable with respect to S ifany history H arising from the algorithm is linearizable with

respect to S.
The problem with linearization points. Proving thata concurrent algorithm is linearizable with respect to a sequential specification amounts to showing that, for everypossible execution, there exists a total linearization order.
The standard strategy is a simulation-style proof where theimplementation and specification histories are constructed
in lock-step. The points where the specification `takes effect'are known as linearization points - to simplify the proof,

2 Our formulation of linearizability differs from the classic
one [14]. Rather than have a history record the total order oncalls and returns, we convert this information into a strict partial order pr. Likewise, linearizability between histories is definedby inclusion on orders, rather than by reordering call and return
events. This approach, taken from [4], is convenient for us becauseour stack theorem is defined by constraints on orders. However,
the two formulations are equivalent.

238

these are often associated with points in the implementa-tion's syntax. Conceptually, when a linearization point is
reached, the method is appended to the linearization order.It has long been understood that linearization points are
a limited approach. Simulation arguments work poorly formany non-blocking algorithms because the specification history is not precisely determined by the implementation. Al-gorithms may have linearization points dictated by complex
interactions between methods, or by non-deterministic fu-ture behaviour. The TS stack is a particularly acute example
of this problem. Two push methods that run concurrentlymay insert elements with unordered timestamps, giving no
information to choose a linearization order. However, if theelements are later popped sequentially, an order is imposed
on the earlier pushes. Worse, ordering two pushes can im-plicitly order other methods, leading to a cascade of linearizations back in time.Consider the following history. Horizontal lines represent
execution time, !| represents calls, and "| returns.

!"#$%!& !'!%&\Gamma "!"#$%"&

!'!%&\Gamma !!"#$%#& !'!%&\Gamma #

This history induces the precedence order pr represented bysolid lines in the following graph.

!"#$%!& !'!%&\Gamma "!"#$%"&

!'!%&\Gamma !!"#$%#& !'!%&\Gamma # %(&
%)&%*& %+&
!, !,

!,

!,

!,

!,

First consider the history immediately before the return ofpop()!

c (i.e. without order (1) in the graph). As push(b)and push(

c) run concurrently, elements b and c may haveunordered timestamps. At this point, there are several consistent ways that the history might linearize, even given ac-cess to the TS stack's internal state.

Now consider the history after pop()!b. Dotted edgesrepresent linearization orders forced by this operation. As

cis popped before
b, LIFO order requires that push(b) hasto be linearized before push(

c) - order (2). Transitivitythen implies that push(
a) has to be ordered before push(c)- order (3). Furthermore, ordering push(

a) before push(c)requires that pop()!
c is ordered before pop()!a - order (4).Thus a method's linearization order may be fixed long after

it returns, frustrating any attempt to identify linearizationpoints.

Specification-specific conditions (AKA aspects). Fora given sequential specification, it may not be necessary to
find the entire linearization order to show that an algorithmis linearizable. A degenerate example is the specification
which contains all possible sequential histories; in this case,we need not find a linearization order, because any order
consistent with pr will do. One alternative to linearizationpoints is thus to invent special-purpose conditions for particular sequential specifications.Henzinger et al. [12] have just such a set of conditions
for queues. They call this approach aspect-oriented. Oneattractive property of their approach is that their queue
conditions are mostly expressed using precedence order, pr.In other words, most features of queue behaviour can be
checked without locating linearization points at all. (Theexception is emptiness checking, which also requires special
treatment in our approach - see below.)

Stack and set specifications. Our theorem makes use oftwo sequential specifications: Stack, and a weaker specification Set that does not respect LIFO order. We definethe set of permitted histories by defining updates over abstract states. Assume a set of values Val. Abstract statesare finite sequences in Val*. Let

! & Val* be an arbitrarystate. In Stack, push and pop have the following sequential

behaviour (`*' means sequence concatenation):*

push(v) - Update the abstract state to ! * [v].*
pop() - If ! = [], return EMPTY. Otherwise, ! must beof the form

!" * [v"]. Update the state to !", return v".

In Set, push is the same, but pop behaves as follows:

* pop() - If ! = [], return EMPTY. Otherwise, ! must be ofthe form

!" *[v"]*!"". Update the state to !" *!"", return v".

4.1 The Stack Theorem
We have developed stack conditions sufficient to ensure lin-earizability with respect to Stack. Unlike [12], our conditions are not expressed using only pr (indeed, we believe thiswould be impossible - see $4.2). Rather we require an auxiliary insert-remove relation ir which relates pushes to popsand vice versa, but that does not relate pairs of pushes or
pairs of pops. In other words, our theorem shows that forstacks it is sufficient to identify just part of the linearization
order.We begin by defining the helper orders ins and rem over
push operations and pop operations, respectively. Infor-mally, ins and rem are fragments of the linearization order
that are imposed by the combination of ir and the precedenceorder pr. In all the definitions in this section, assume that
H = "A, pr, val# is a history. Below we write +a, +b, +c etc.for push operations, and -

a, -b, -c etc. for pop operations.

Definition 3 (derived orders ins and rem). Assume aninsert-remove relation ir.

* For all +a, +b & A, +a ins-( +b if either +a pr-( +b or

there exists an operation -c & A with +a pr-( -c ir-( +b.* For all -

a, -b & A, -a rem--( -b if either -a pr-( -b orthere exists an operation +

c & A with -a ir-( +c ir-( -b.

The order ins expresses ordering between pushes imposedeither by precedence, or transitively by insert-remove. Likewise rem expresses ordering between pops. Using ins andrem, we can define order-correctness, which expresses the
conditions necessary to achieve LIFO ordering in a stack.In our formulation ins is weaker than rem - note the pr
rather than ir in the final clause. However, our stack theoremalso holds if the definitions are inverted, with rem weaker
than ins. The version above is more convenient in verifyingthe TS stack.

Definition 4 (alternating). We call a relation r on Aalternating if every pair +

a, -b & A consisting of one pushand one non-empty pop is ordered, and no other pairs are

ordered.
Definition 5 (order-correct). We call H order-correct ifthere exists an alternating relation ir on A, and derived

orders ins and rem, such that:

1. ir ) pr is cycle-free; and
2. Let +a, -a, +b & A with +a val-( -a and +a pr-( -a.If +

a ins-( +b ir-( -a, then there exists -b & A with
+b val-( -b and -a *rem--( -b;

239

Condition (2) is at the heart of our proof approach. Itforbids the non-LIFO behaviour illustrated in Figure 3.
Order-correctness only imposes LIFO ordering; it doesnot guarantee non-LIFO correctness properties. For a stack
these are (1) elements should not be lost; (2) elements shouldnot be duplicated; (3) popped elements should come from
a corresponding push; and (4) pop should report EMPTYcorrectly. The last is subtle, as it is a global rather than
pairwise property: pop should return EMPTY only at a pointin the linearization order where the abstract stack is empty.

Fortunately, these properties are also orthogonal to LIFOordering: we just require that the algorithm is linearizable
with respect to Set (simple to prove for the TS stack).For properties (1)-(3) it is trivial why this is sufficient. For
emptiness checking, any history satisfying Set can be splitinto sub-histories free of pop-empty. As a pop-empty can
only occur when no elements are in the data-structure, anysuch partitioning is also valid in Stack. Thus, the correctness of emptiness checking can be established separatelyfrom LIFO ordering.

Theorem 1 (stack correctness). Let C be a concurrent al-gorithm. If every history arising from

C is order-correct, and
C is linearizable with respect to Set, then C is linearizablewith respect to Stack.

Proof. Here we only sketch five stages of the proof. For fulldetails see supplementary Appendix A. (1) Order all pop
operations which do not return empty and which are orderedwith their matching push operation in the precedence order.
(2) Adjust the ir relation to deal with the definition of insdiscussed above. Again we ignore all push-pop pairs with
overlapping execution times. (3) Order all push operationswhich remain unordered after the first two stages and show
that the resulting order is within Stack. (4) Show thatpush-pop pairs with overlapping execution times can always
be added to a correct linearization order without violatingStack. (5) Show that also pop operations which return
EMPTY can always be added to a correct linearization orderas long as they are correct with respect to Set.

For the TS stack, the advantage of Theorem 1 is thatproblematic orderings need not be resolved. In the example
discussed above, push(a) and push(c) can be left unorderedin ir, removing the need to decide their eventual linearization
order; likewise pop()!a and pop()!c. As we show in the nextsection, the ir relation can be extracted from the TS stack
using an adapted version of the linearization point method.Our stack theorem is generic, not tied to the TS stack. It
characterises the internal ordering sufficient for an algorithmto achieve stack semantics. As well as sound, it is complete
- for any linearizable stack, ir can be trivially projectedfrom the linearization order. For CAS-based stacks such
as Treiber's famous non-blocking stack [22] it is simple tosee intuitively why the theorem applies. If two pushes are
ordered, then their CASes are ordered. As a result theirelements will be ordered in the stack representation and
removed in order.Intuitively, our theorem seems close to the lower bound
for stack ordering. The next section ($4.2) provides evidencefor this by ruling out the class of weaker formulations without ir. Intuitively, we would expect any concurrent stack toenforce orders as strong as the ones in our theorem. Thus,
Theorem 1 points towards fundamental constraints on thestructure of concurrent stacks.

!"!#$\Gamma !
!"!#$\Gamma "!%&'#"$

!"!#$\Gamma #

!"!#$\Gamma $
!%&'##$

!%&'#$$

!%&'#!$

!"#$%!&
!'!%&\Gamma !

()*

!'!%&\Gamma "!'!%&\Gamma #

!"#$%#&

!'!%&\Gamma $

!"#$%$&
()*

!"#$%"&
()* ()*
*+,

!-

!-

*+,
!-

!-

*+,
!-

!-

!-
Figure 4: Top: example non-linearizable execution exhibitingnon-local behaviour. Bottom: corresponding graph projecting out pr, val, and lin relations.

Mechanisation. We have mechanised Theorem 1 in theIsabelle theorem prover. The source files for this proof are
provided in supplementary file stackthm.tgz. Supplemen-tary Appendix A discusses the structure of our mechanisation alongside with an informal proof of the theorem.
4.2 Why the Insert-Remove Relation is Necessary
Theorem 1 builds on a similar theorem for queues proved byHenzinger et al. [12]. As in our definition of order-correctness

(Definition 5), their theorem forbids certain bad orderingsbetween operations. However, their conditions are defined
purely in terms of precedence, pr, and value, val - they donot require the auxiliary insert-remove relation ir.

We believe that any stack theorem similar in structureto ours must require some additional information like ir
(and as a corollary, that checking linearizability for stacksis fundamentally harder than for queues). By `similar', we
mean a local theorem defined by forbidding a finite numberof finite-size bad orderings. It is this locality that makes
our theorem and Henzinger's so appealing. It reduces data-structure correctness from global ordering to ruling out a
number of specific bad cases.Our key evidence that the insert-remove relation is
needed is the execution shown in Figure 4 (top). This exe-cution as a whole is not linearizable - this can be seen more
clearly in corresponding graph in Figure 4 (bottom), whichprojects out the pr and val relations. Here lin is the linearization order forced by LIFO ordering. The pr)lin edges form acycle, contradicting the requirement that linearization order
is acyclic and includes pr.However, if for any

i & {a, b, c, d} the correspondingpush(
i)-pop(i) pair is deleted, the execution becomes lin-earizable. Intuitively, doing this breaks the cycle in lin ) pr

that appears above. Thus, any condition based on prece-dence that is smaller than this whole execution cannot forbid
it - otherwise it would forbid legitimate executions. Worse,we can make arbitrarily large bad executions of this form.
Thus no theorem based on finite-size condition can definelinearizability for stacks. Our insert-remove relation introduces just enough extra structure to let us define a localstack theorem.

This kind of execution is not a problem for queues be-cause ordering an insert-remove pair cannot constrain the
insert-insert or remove-remove order of any other pair.

240

5. Proving the TS Stack Correct
We now prove the TS Stack correct. We use a two-levelargument to separate concerns in the proof. By verifying a

lower-level structure first, we hide the complexities of thedata-structure from the higher-level proof.

1. Prove the linearizability of an intermediate structurecalled the TS buffer. This shows that the SP pools

combine to form a single consistent pool, but does notenforce LIFO ordering.

2. Use our stack theorem (Theorem 1) to prove the TS stackis linearizable with respect to LIFO stack semantics.

Linearizability lets us use the lower-level TS buffer interms of its sequential specification.

5.1 TS Buffer Linearizability
The TS buffer is a `virtual' intermediate data-structure, i.e.a proof convenience that does not exist in the algorithm

syntax. (It would be easy to add, but would make our codemore complex). The TS buffer methods are the lines in push
and pop which modify the spPools array and thread-specificpools. Proving the TS buffer linearizable means these lines
can be treated as atomic. We name the TS buffer operationsas follows - line numbers refer to Listing 1. Note that where
possible these names coincide with names in Listing 1.

* ins - inserts an element into an SP pool (line 13).

* newTimestamp - generates a new timestamp (line 14).

* setTimestamp - assign a timestamp to a SP pool element(line 15).

* getStart - record the current time at the beginning ofa pop (line 20).

* tryRem - search through the SP pools and try to removethe element with the youngest timestamp (line 24).

Note that newTimestamp and getStart have the same under-lying implementation, but different abstract specifications.
This is because they play different roles in the TS stack:respectively, generating timestamps for elements, and controlling elmination.The abstract state of the TS buffer hides individual
SP pools by merging all the elements into a single pool.As elements may be eliminated depending on when the
method started, the abstract state also records snapshotsrepresenting particular points in the buffer's history.

As with Stack and Set, we define the sequential speci-fication TSbuf by tracking updates to abstract states. Formally, we assume a set of buffer identifiers, ID, representingindividual buffer elements; and a set of timestamps, TS, with
strict partial order <TS and top element !. A TSbuf ab-stract state is a tuple (

B, S). B & Buf is a partial map fromidentifiers to value-timestamp tuples, representing the current values stored in the buffer. S & Snapshots is a partialmap from timestamps to Buf, representing snapshots of the
buffer at particular timestamps.

Buf : ID " (Val * TS) Snapshots : TS " Buf
We implicitly assume that all timestamps in the buffer werepreviously generated by newTimestamp.

Snapshots are used to support globally consistent re-moval. To remove from the buffer, pop first calls getStart
to generate a timestamp t - abstractly, [t +( B] is addedto the library of snapshots. When pop calls tryRem(t), elements that were present when t was generated may be removed normally, while elements added or timestamped morerecently than t may be eliminated out of order. The stored
snapshot S(t) determines which element should be removedor eliminated.

The TS buffer functions have the following specifications,assuming (

B, S) is the abstract state before the operation:*

newTimestamp() - pick a timestamp t *= ! such that forall

t" *= ! already in B, t" <TS t. Return t.

Note that this means many elements can be issued thesame timestamp if the thread is preempted before writing

it into the buffer.*
ins(v) - Pick an ID i /& dom(B). Update the state to(

B[i +( (v, !)], S) and return i.*

setTimestamp(i,t) - assume that t was generated bynewTimestamp(). If

B(i) = (v, !), then update theabstract state to (
B[i +( (v, t)], S). If B(i) = ,, donothing.

* getStart() - pick a timestamp t *= ! such that t /&dom(

S) or t & dom(S) and S(t) = B. If t /& dom(S),update the state to (

B, S[t +( B]). Return t.*

tryRem(t) - Assume t & dom(S). There are four possiblebehaviours:

1. failure. Non-deterministically fail and return "false, null#.This corresponds to a failed SP pool remove preempted by another thread.
2. emptiness check. If the map is empty (i.e. dom(B) =-) then return "true

, EMPTY#.

3. normal removal. Pick an ID i with i & dom(S(t)) .dom(

B) and B(i) +( (vi, ti) such that ti is maximalwith respect to other unremoved elements from the

snapshot, i.e.

!i", t". i" & (dom(S(t)) . dom(B)) / B(i") = ( , t")/

ti <TS t"

Update the abstract state to (B[i +( ,], S) and return"true

, vi#. Note that there may be many maximalelements that could be returned.

4. elimination. Pick an ID i such that i & dom(B), andeither

i /& dom(S(t)) and B(i) +( (v, ); or S(t)(i) +((
v, !). Update the abstract state to (B[i +( ,], S)and return "true

, v#.

This corresponds to the case where v was inserted ortimestamped after pop called getStart, and

v cantherefore be removed using elimination.

Theorem 2. TS buffer operations are linearizable withrespect to the specification TSbuf.

Proof. The concrete state of the TS buffer consists of thearray spPools, where each slot points to a SP pool, i.e. a
linked list of nodes. For the abstract state, the mapping Bufis easily built by erasing taken nodes. We build Snapshots
by examining the preceding trace. Snapshots are generatedfrom the state of the buffer at any point getStart is called.

ins and setTimestamp are SP pool operations which takeeffect atomically because they build on atomic operations,
i.e. the assignment to top in line 81, and to timestamp inline 15, respectively.

newTimestamp and getStart both build on the sametimestamping operation. Only concurrent timestamp requests can generate overlapping timestamps. As timestampshave to be generated and then added to the buffer separately,

241

at the call of newTimestamp and getStart an overlappingtimestamp cannot be in the buffer. For getStart, the snapshot is correctly constructed automatically as a consequenceof the mapping from concrete to abstract state.

The most complex proof is for tryRem, where the lin-earization point is in the call to remove. tryRem always removes a valid element because any element in the snapshotis guaranteed to be contained in one of the SP pools before
tryRem starts its search for the youngest element. Any re-moved element not in the snapshot must have been added
since the start of the search, and thus satisfies the elimina-tion case of the specification. Further details are given in
supplementary Appendix C.
5.2 TS Stack Linearizability
We now prove that the TS stack is correct. We first definetwo orders vis and rr on push and pop operations. These

orders are extracted from executions using a method anal-ogous to linearization points, except that we generate two,
possibly conflicting orders. The points chosen correspond toTS buffer operations. In $5.1 we proved that the TS buffer
is linearizable, so we can treat these points as atomic.

* vis (`visibility' - the element inserted by a push wasvisible to a pop). A push and non-empty pop are ordered

in vis if SP pool insertion in the push (line 13) is orderedbefore recording the current time in the pop (line 20).

* rr (`remove-remove' - two pops removed elements inorder). Two non-empty pop operations are ordered in

rr if their final successful tryRem operations (line 24) aresimilarly ordered in the execution.

As with ins / rem in the stack theorem, it is useful to define ahelper order ts (`timestamp') on push operations. This order
is imposed by precedence and vis transitivity. Informally, iftwo push operations are ordered in ts their elements are
ordered in <TS.
Definition 6 (derived order ts). Assume a history H ="A

, pr, val# and order vis on A. Two operations +a, +b & A

are related +a ts-( +b if: +a pr-( +b; or +a pr-( -c vis-( +bfor some -

c & A; or +a pr-( +d vis-( -c vis-( -b for some-
c, +d & A.

To apply Theorem 1 and to show that the TS stack iscorrect we need to show that any history arising from the

TS stack is order-correct (Definition 5). The following lemmaconnects vis, rr and ts to this notion of order-correctness.

Lemma 3. Let H = "A, pr, val# be a history. Assume vis, analternating order on A, and rr, a total order on non-empty
pop operations in A. Assume the derived order ts. If:

1. pr ) vis and pr ) rr are cycle-free; and
2. for all +a, -a, +b & A such that +a val-( -a, +a pr-( -a,and +

a ts-( +b vis-( -a, there exists -b & A such that+
b val-( -b and -b rr-( -a;

then H is order-correct according to Definition 5.

Proof. The proof works by using vis, rr and ts to constructa relation ir witnessing that H is order-correct. Either vis is
such a witness, or vis can be adjusted locally such that itbecomes a witness. Adjustment works iteratively by identifying triples of operations which violate order-correctness,then pushing one of the operations earlier or later in the relation to remove the violation. The detail of the proof consists of a case analysis showing that for any execution, suchadjustments are always possible and eventually terminate.
Further details are given in supplementary Appendix B.
Lemma 4. TS stack is linearizable with respect to Set.
Proof. Straightforward from the fact that the TS buffer islinearizable with respect to TSbuf. We take the linearization point for push as the call to ins and the linearizationpoint for pop as the call to tryRem. Correctness follows from
the specification of TSbuf.
Theorem 5. TS stack is linearizable with respect to Stack.
Proof. Follows by applying our stack theorem. Lemma 4deals with the first clause of Theorem 1. The other clause
requires the existence of an ir relation that satisfies order-correctness. It suffices to show that vis, rr, and ts satisfy
the preconditions of Lemma 3. The first requirement thatpr)vis and pr)rr are cycle-free, follows from the fact that the

instructions used to define vis and rr are linearization pointsof the TS buffer. The second requirement for the lemma
follows from the fact that ordering in ts implies orderingin

<TS, and the fact that the TS stack removes elementsin an order that respects

<TS. Further details are given insupplementary Appendix B.

Theorem 6. The TS stack is lock-free.
Proof. Straightforward from the structure of tryRem: re-moval can only fail when another thread succeeds.

6. Performance Analysis
Our experiments compare the performance and scalability ofthe TS stack with two high-performance concurrent stacks:

the Treiber stack [22] because it is the de-facto standardlock-free stack implementation; and the elimination-backoff
(EB) stack [9] because it is the fastest concurrent stack weare aware of.3 We configured the Treiber and EB stacks to
perform as well as possible on our test machines: see belowfor the parameters used.

We ran our experiments on two x86 machines:

* an Intel-based server with four 10-core 2GHz Intel Xeonprocessors (40 cores, 2 hyperthreads per core), 24MB

shared L3-cache, and 128GB of UMA memory runningLinux 3.8.0-36; and

* an AMD-based server with four 16-core 2.3GHz AMDOpteron processors (64 cores), 16MB shared L3-cache,

and 512GB of cc-NUMA memory running Linux 3.5.0-49.

Measurements were done in the Scal BenchmarkingFramework [5]. To avoid measurement artifacts the framework uses a custom memory allocator which performs cyclicallocation [19] in preallocated thread-local buffers for objects smaller than 4096 bytes. Larger objects are allocatedwith the standard allocator of glibc. All memory is allocated
cache-aligned when it is beneficial to avoid cache artifacts.
3 Of course, other high-performance stacks exist. We decided
against benchmarking the DECS stack [3] because (1) no imple-mentation is available for our platform and (2) according to their

experiments, in peak performance it is no better than a Flat Com-bining stack. We decided against benchmarking the Flat Combining stack because the EB stack outperforms it when configuredto access the backoff array before the stack itself.

242

40-core machine 64-core machine
high-contention:TS-interval stack 7 us 6 us

TS-CAS stack 6 us 10.5 us
low-contention:TS-interval stack 4

.5 us 4.5 usTS-CAS stack 3 us 9 us

Table 1: Benchmark delay times for TS-interval / TS-CAS.

The framework is written in C/C++ and compiled withgcc 4.8.1 and -O3 optimizations.

Scal provides implementations of the Treiber stack andof the EB stack. Unlike the description of the EB stack
in [9] we access the elimination array before the stack -this improves scalability in our experiments. We configured
the EB stack such that the performance is optimal in ourbenchmarks when exercised with 80 threads on the 40-
core machine, or with 64 threads on the 64-core machine.These configurations may be suboptimal for lower numbers
of threads. Similarly, the TS stack configurations we discusslater are selected to be optimal for 80 and 64 threads on the
40-core and 64-core machine, respectively. On the 40-coremachine the elimination array is of size 16 with a delay of
18 us in the high-contention benchmark, and of size 12 witha delay of 18 us in the low contention benchmark. On the 64-
core machine the elimination array is of size 32 with a delayof 21 us in the high-contention benchmark, and of size 16
with a delay of 18 us in the low contention benchmark.On the 64-core machine the Treiber stack benefits from
a backoff strategy which delays the retry of a failed CAS.On this machine, we configured the Treiber stack with a
constant delay of 300 us in the high-contention experimentsand a constant delay of 200 us in the low-contention experiments, which is optimal for the benchmark when exercisedwith 64 threads. On the 40-core machine performance decreases when a backoff delay is added, so we disable it.We compare the data-structures in producer-consumer
microbenchmarks where threads are split between dedicatedproducers which insert 1,000,000 elements into the datastructure, and dedicated consumers which remove 1,000,000elements from the data-structure. We measure performance
as total execution time of the benchmark. Figures show thetotal execution time in successful operations per millisecond
to make scalability more visible. All numbers are averagedover 5 executions. To avoid measuring empty removal, operations that do not return an element are not counted.The contention on the data-structure is controlled by a
computational load which is calculated between two opera-tions of a thread. In the high-contention scenario the computational load is a #-calculation in 250 iterations, in thelow-contention scenario

# is calculated in 2000 iterations.On average a computational load of 1000 iterations corresponds to a delay of 2.3 us on the 40-core machine.

6.1 Performance and Scalability Results
Figures 5a and 5b show performance and scalability in aproducer-consumer benchmark where half of the threads are

producers and half of the threads are consumers. These fig-ures show results for the high-contention scenario. Results
for the low-contention scenario are similar, but less pro-nounced - see Figure 7 in the supplementary material.

For TS-interval timestamping and TS-CAS timestampingwe use the optimal delay when exercised with 80 threads
on the 40-core machine, and with 64 threads on the 64-core machine, derived from the experiments in Section 6.2.
The delay thus depends on the machine and benchmark.The delay times we use in the benchmarks are listed in
Table 1. The impact of different delay times on performanceis discussed in Section 6.2.

Comparison between implementations. TS-intervalis faster than the other timestamping algorithms in the
producer-consumer benchmarks with an increasing numberof threads. Interestingly the TS-atomic stack is faster than
the TS-hardware stack in the high-contention producer-consumer benchmark. The reason is that since the push operations of the TS-hardware stack are so much faster thanthe push operations of the TS-atomic stack, elimination is
possible for more pop operations of the TS-atomic stack (e.g.41% more elimination on the 64-core machine, see Table 2
in the supplementary appendix), which results in a factor of3 less retries of tryRem operations than in the TS-hardware
stack. On the 40-core machine the TS-stutter stack is sig-nificantly slower than the TS-atomic stack, while on the
64-core machine the TS-stutter stack is faster. The reasonis that on the 40-core machine TS-stutter timestamping is
significantly slower than TS-atomic timestamping (see Fig-ure 5c). On the 40-core machine the TS-CAS stack is much
faster than the TS-hardware stack, TS-atomic stack, andTS-stutter stack, on the 64-core machine it is slightly faster.
The reason is that on the 64-core machine a CAS is slowerin comparison to other instructions than on the 40-core
machine.
Comparison with other data-structures. With morethan 16 threads all TS stacks are faster than the Treiber

stack. On both machines the TS-interval stack and the TS-CAS stack outperform the EB stack in the high-contention
producer-consumer benchmark with a maximum number ofthreads, on the 64-core machine also the TS-stutter stack
and the TS-atomic stack are sightly faster than the EB stack.We believe TS-interval's and TS-CAS's performance increase with respect to the EB stack comes from threesources: (a) more elimination; (b) faster elimination; (c)
higher performance without elimination. As shown in producer-only and consumer-only experiments, the lack of pushcontention and mitigation of contention in pop makes ourstack fast even without elimination. Additional experiments
show that for example the TS-interval stack eliminates7% and 23% more elements than the EB stack in highcontention scenarios on the 40-core and on the 64-core ma-chine, respectively. Thus we improve on EB in both (a)
and (c). (b) is difficult to measure, but we suspect integrat-ing elimination into the normal code path introduces less
overhead than an elimination array, and is thus faster.
Push performance. We measure the performance of pushoperations of all data-structures in a producer-only benchmark where each thread pushes 1,000,000 element into thestack. The TS-interval stack and the TS-CAS stack use
the same delay as in the high-contention producer-consumerbenchmark, see Table 1:

Figure 5c and Figure 5d show the performance and scala-bility of the data-structures in the high-contention produceronly benchmark. The push performance of the TS-hardwarestack is significantly better than the push of the other stack
implementations. With an increasing number of threads thepush operation of the TS-interval stack is faster than the

243

T\Gamma \Delta \Theta \Lambda \Delta \Gamma  \Xi \Pi \Sigma \Upsilon \Phi 

E\Psi  \Xi \Pi \Sigma \Upsilon \Phi 

T\Xi \Omega \Sigma \Pi fffi\Theta \Upsilon  \Xi \Pi \Sigma \Upsilon \Phi 

T\Xi \Omega flffi\Xi  \Xi \Pi \Sigma \Upsilon \Phi 

T\Xi \Omega ffl\Sigma \Gamma ij\Sigma \Gamma \Delta  \Xi \Pi \Sigma \Upsilon \Phi 

T\Xi \Omega \Theta `\Pi \Delta \Gamma '\Sigma ^ \Xi \Pi \Sigma \Upsilon \Phi 

T\Xi \Omega *\Pi _\Pi \Pi \Delta \Gamma  \Xi \Pi \Sigma \Upsilon \Phi 


*
,
ss
ae
oe
oe*

* oe * 3 , 5 ss 7 ae
oo/
AEOE
O/!"

o#
$o/

AEOE
%$

&%
oOE
AE"

$'

AE!!
AEOE
(

n)*+,- ./ 01-,246
(a) Producer-consumer benchmark, 40-core machine.

8
9888
:888
;888
!888
=8888
=9888

9 ! =; 9: ?9 :8 :! ?; ;:
@A
BC
DFG

@H
IA

BC
JI

KJ
@C
BG

IL

BFF
BC
M

NOPQRS UV WXSRYZ[
(b) Producer-consumer benchmark, 64-core machine.

"
]""""
^""""
.""""
`""""
a""""
b""""

] ]" ^" ." `" a" b" c" d"
ef
gh
ijk

el
mf

gh
p
mq

pe

hg
km
rg
jjg
hs

tuvwxy z- --""yx~"A*
(c) Producer-only benchmark, 40-core machine.

A,
C'A,A,A,A,
C^A,A,A,A,
D^A,A,A,A,
E^A,A,A,A,
E,A,A,A,A,
G*A,A,A,A,

C' L' C'G* C^E^ D^C^ E^A, E^L' E,G* G*E^
L^L/
N'N^
NGO""R'

L^R^
S'L/

N'N^
S^
S'S,

S^L^

N^N'
R'S'
T^N'
O""O""N'
N^T,

U""U*Y"Z'Z^Z. IJI. d-$Z.Z^a*a,c'
(d) Producer-only benchmark, 64-core machine.

c^
d^c^c^
e^c^c^c^
e^d^c^c^
e,c^c^c^
e,d^c^c^
g*c^c^c^
g*d^c^c^

e^ e^c^ e,c^ g*c^ l'c^ d^c^ l^c^ l/c^ n'c^
n^ng
o""r'
r^s's^

n^s,
t^ng

o""r'
t,t^

u""t,
n^r'
o""s^

t^u*

o""s'
s'o""
r'y"

z'z^z.ij!? #A` A'A^?!A~A"A*
(e) Consumer-only benchmark, 40-core machine.

AE
C,AEAE
E`AEAEAE
E`C,AEAE
E'AEAEAE
E'C,AEAE
E^AEAEAE
E^C,AEAE

E` E" E`I` E'I' E^E' I'AE I'E" C,I` I`I'
I^I"
DHN~
O`O'O^

I^O~
O"I"

DHN~
OEO"

O/OE
I^N~
DHO^

O"U`

DHO'
O'DH
N~U'

U^U"Y'ThSSa` a'a^ a~a"a`SSa*aec,
(f) Consumer-only benchmark, 64-core machine.

Figure 5: TS stack performance in the high-contention scenario on 40-core machine (left) and 64-core machine (right).

push operations of the TS-atomic stack and the TS-stutterstack, which means that the delay in the TS-interval timestamping is actually shorter than the execution time of theTS-atomic timestamping and the TS-stutter timestamping.
Perhaps surprisingly, TS-stutter, which does not requirestrong synchronisation, is slower than TS-atomic, which is
based on an atomic fetch-and-increment instruction.

Pop performance. We measure the performance of popoperations of all data-structures in a consumer-only benchmark where each thread pops 1,000,000 from a pre-filledstack. Note that no elimination is possible in this benchmark. The stack is pre-filled concurrently, which means incase of the TS-interval stack and TS-stutter stack that some
elements may have unordered timestamps. Again the TS-interval stack uses the same delay as in the high-contention
producer-consumer benchmark.

Figure 5e and Figure 5f show the performance andscalability of the data-structures in the high-contention
consumer-only benchmark. The performance of the TS-interval stack is significantly higher than the performance of
the other stack implementations, except for low numbers ofthreads. The performance of TS-CAS is close to the performance of TS-interval. The TS-stutter stack is faster than theTS-atomic and TS-hardware stack due to the fact that some
elements share timestamps and therefore can be removed inparallel. The TS-atomic stack and TS-hardware stack show
the same performance because all elements have uniquetimestamps and therefore have to be removed sequentially.
Also in the Treiber stack and the EB stack elements have tobe removed sequentially. Depending on the machine, removing elements sequentially from a single list (Treiber stack)is sometimes less and sometimes as expensive as removing
elements sequentially from multiple lists (TS stack).

244


\Gamma 
\Delta 
\Theta 
\Lambda 
\Xi 
\Xi \Gamma 

 3 \Theta  9 \Xi \Gamma  \Xi 1



\Xi 
\Gamma 
3

\Delta 
1
\Theta 
\Pi 

o\Sigma 
\Upsilon \Phi 
\Psi \Omega 
ffo
fifl

\Sigma \Upsilon 
\Phi ffi

fl
fflffi

o\Phi 
\Upsilon 
fffl

i\Upsilon 
\Omega \Omega \Upsilon 
\Phi j

fin
ffi
i\Upsilon 

\Phi o
`\Phi 

\Upsilon \Omega 
\Phi ff\Upsilon 

fl
ffl'\Upsilon 

flfl

fffl
i\Upsilon 
\Omega \Omega \Upsilon 
\Phi j

d^*_* ,ss ssae

P^oeo/AEoeOE_ssO/^ !"#,ss$^oe%_* "$_O/&

R^$oe,^ae !"#,ss$^oe%_* "$_O/&
P^oeo/AEoeOE_ssO/^ !"#'(" "$_O/&

R^$oe,^ae !"#'(" "$_O/&

Figure 6: High-contention producer-consumer benchmarkusing TS-interval and TS-CAS timestamping with increasing delay on the 40-core machine, exercising 40 producersand 40 consumers.

6.2 Analysis of Interval Timestamping
Figure 6 shows the performance of the TS-interval stackand the TS-CAS stack along with the average number of

tryRem calls needed in each pop (one call is optimal, butcontention may cause retries). These figures were collected
with an increasing interval length in the high contentionproducer-consumer benchmark on the 40-core machine. We
used these results to determine the delays for the bench-marks in Section 6.1.

Initially the performance of the TS-interval stack in-creases with an increasing delay time, but beyond 7

.5 us theperformance decreases again. After that point an average

push operation is slower than an average pop operation andthe number of pop operations which return EMPTY increases.

For the TS-interval stack the high performance correlatesstrongly with a drop in tryRem retries. We conclude from this
that the impressive performance we achieve with intervaltimestamping arises from reduced contention in tryRem. For
the optimal delay time we have 1.009 calls to tryRem perpop, i.e. less than 1% of pop calls need to scan the SP
pools array more than once. In contrast, without a delaythe average number of retries per pop call is more than 6.

The performance of the TS-CAS stack increases initiallywith an increasing delay time. However this does not decrease the number of tryRem retries significantly. The rea-son is that without a delay there is more contention on the
global counter. Therefore the performance of TS-CAS witha delay is actually better than the performance without a
delay. However, similar to TS-interval timestamping, witha delay time beyond 6 us the performance decreases again.
This is the point where an average push operation becomesslower than an average pop operations.

7. TS Queue and TS Deque Variants
In this paper, we have focussed on the stack variant of ouralgorithm. However, stored timestamps can be removed in

any order, meaning it is simple to change our TS stack intoa queue / deque. Doing this requires three main changes:

1. Change the timestamp comparison operator in tryRem.
2. Change the SP pool such that getYoungest returns theoldest / right-most / left-most element.

3. For the TS queue, remove elimination in tryRem. For theTS deque, enable it only for stack-like removal.

The TS queue is the second fastest queue we know of. In ourexperiments the TS-interval queue outperforms the MichaelScott queue [18] and the flat-combining queue [10] but thelack of elimination means it is not as fast as the LCRQ [1].

The TS-interval deque is the fastest deque we know of,although it is slower than the corresponding stack / queue.
However, it still outperforms the Michael-Scott and flat-combining queues, and the Treiber and EB stacks.

8. Related Work
Timestamping. Our approach was initially inspired byAttiya et al.'s Laws of Order paper [2], which proves that

any linearizable stack, queue, or deque necessarily uses theRAW or AWAR patterns in its remove operation. While
attempting to extend this result to insert operations, wewere surprised to discover a counter-example: the TS stack.
We believe the Basket Queue [15] was the first algorithm toexploit the fact that enqueues need not take effect in order
of their atomic operations, although unlike the TS stack itdoes not avoid strong synchronisation when inserting.

Gorelik and Hendler use timestamping in their AFCqueue [6]. As in our stack, enqueued elements are timestamped and stored in single-producer buffers. Aside fromthe obvious difference in kind, our TS stack differs in several
respects. The AFC dequeue uses flat-combining-style con-solidation - that is, a combiner thread merges timestamps
into a total order. As a result, the AFC queue is block-ing. The TS stack avoids enforcing an internal total order,
and instead allows non-blocking parallel removal. Removalin the AFC queue depends on the expensive consolidation
process, and as a result their producer-consumer benchmarkshows remove performance significantly worse than other
flat-combining queues. Interval timestamping lets the TSstack trade insertion and removal cost, avoiding this problem. Timestamps in the AFC queue are Lamport clocks [17],not hardware-generated intervals. (We also experiment with
Lamport clocks - see TS-stutter in $3.2). Finally, AFC queueelements are timestamped before being inserted - in the TS
stack, this is reversed. This seemingly trivial difference en-ables timestamp-based elimination, which is important to
the TS stack's performance.The LCRQ queue [1] and the SP queue [11] both index
elements using an atomic counter. However, dequeue opera-tions do not look for one of the youngest elements as in our
TS stack, but rather for the element with the enqueue indexthat matches the dequeue index exactly. Both approaches
fall back to a slow path when the dequeue counter becomeshigher than the enqueue counter. In contrast to indices,
timestamps in the TS stack need not be unique or even or-dered, and the performance of the TS stack does not depend
on a fast path and a slow path, but only on the number ofelements which share the same timestamp.

Our use of the x86 RDTSCP instruction to generate hard-ware timestamps is inspired by work on testing FIFO
queues [7]. There the RDTSC instruction is used to deter-mine the order of operation calls. (Note the distinction between the synchronised RDTSCP and unsynchronised RDTSC).RDTSCP has since been used in the design of an STM by Ruan
et al. [20], who investigate the instruction's multi-processorsynchronisation behaviour.

Correctness. Our stack theorem lets us prove that theTS stack is linearizable with respect to sequential stack
semantics. This theorem builds on Henzinger et al. whohave a similar theorem for queues [12]. Their theorem is

245

defined (almost) entirely in terms of the sequential order onmethods - what we call precedence, pr. That is, they need
not generate a linearization order. In contrast, our stacktheorem requires a relation between inserts and removes. We
suspect it is impossible to define such a theorem for stackswithout an auxiliary insert-remove relation (see $4.2).

A stack must respect several non-LIFO correctness prop-erties: elements should not be lost or duplicated, and pop
should correctly report when the stack is empty. Henzingeret al. build these properties into their theorem, making it
more complex and arguably harder to use. Furthermore,each dequeue that returns EMPTY requires a partition `before' and `after' the operation, effectively reintroducing apartial linearization order. However, these correctness properties are orthogonal to LIFO ordering, and so we simplyrequire that the algorithm also respects set semantics.

Implementation features. Our TS stack implementationreuses concepts from several previous data-structures.

Storing elements in multiple partial data-structures isused in the distributed queue [8], where insert and remove
operations are distributed between partial queues using aload balancer. One can view the SP pools as partial queues
and the TS stack itself as the load balancer. The TS stackemptiness check also originates from the distributed queues.
However, the TS stack leverages the performance of dis-tributed queues while preserving sequential stack semantics.

Elimination originates in the elimination-backoff stack [9].However, in the TS stack, elimination works by comparing
timestamps rather than by accessing a collision array. Asa result, in the TS stack a pop which eliminates a concurrent push is faster than a normal uncontended pop. In theelimination-backoff stack such an eliminating pop is slower,
as synchronization on the collision array requires at leastthree successful CAS operations instead of just one.

9. Conclusions and Future Work
We present a novel approach to implementing ordered con-current data-structures like queues, stacks, and deques; a

high-performance concurrent algorithm, the TS stack; anda new proof technique required to show the TS stack is correct. The broad messages that we draw from our work are:

* In concurrent data-structures, total ordering on internaldata imposes a performance cost and is unnecessary for

linearizability.*
However, weakened internal ordering makes establishingcorrectness more challenging. Specification-specific theorems such as our stack theorem can solve this problem.
Our work represents an initial step in designing and verifyingtimestamped data-structures. In future work, we plan to experiment with relaxing other internal ordering constraints;with dynamically adjusting the level of order in response to
contention; with correctness conditions weaker than lineariz-ability; and with relaxing the underlying memory model.

Acknowledgments
We thank Ana Sokolova for feedback, Frank Zeyda for helpwith the Isabelle formalization, and Michael Lippautz for

help with Scal. We also thank the POPL referees for theirthoughtful comments. This work has been supported by
the National Research Network RiSE on Rigorous SystemsEngineering (Austrian Science Fund (FWF): S11404-N23).

References

[1] Y. Afek and A. Morrison. Fast concurrent queues for x86processors. In PPoPP. ACM, 2013.

[2] H. Attiya, R. Guerraoui, D. Hendler, P. Kuznetsov,M. Michael, and M. Vechev. Laws of order: expensive synchronization in concurrent algorithms cannot be eliminated.In POPL, 2011.

[3] G. Bar-Nissan, D. Hendler, and A. Suissa. A dynamicelimination-combining stack algorithm. In OPODIS, 2011.
[4] M. Batty, M. Dodds, and A. Gotsman. Library abstractionfor C/C++ concurrency. In POPL, 2013.
[5] Computational Systems Group, University of Salzburg. Scalframework. URL http://scal.cs.uni-salzburg.at.
[6] M. Gorelik and D. Hendler. Brief announcement: an asym-metric flat-combining based queue algorithm. In PODC,

2013.
[7] A. Haas, C. Kirsch, M. Lippautz, and H. Payer. How FIFOis your concurrent FIFO queue? In RACES. ACM, 2012.

[8] A. Haas, T. Henzinger, C. Kirsch, M. Lippautz, H. Payer,A. Sezgin, and A. Sokolova. Distributed queues in shared

memory--multicore performance and scalability throughquantitative relaxation. In CF. ACM, 2013.

[9] D. Hendler, N. Shavit, and L. Yerushalmi. A scalable lock-free stack algorithm. In SPAA. ACM, 2004.
[10] D. Hendler, I. Incze, N. Shavit, and M. Tzafrir. Flat combin-ing and the synchronization-parallelism tradeoff. In SPAA,

2010.
[11] T. Henzinger, H. Payer, and A. Sezgin. Replacing compe-tition with cooperation to achieve scalable lock-free FIFO

queues. Technical Report IST-2013-124-v1+1, IST Austria,2013.

[12] T. A. Henzinger, A. Sezgin, and V. Vafeiadis. Aspect-oriented linearizability proofs. In CONCUR, 2013.
[13] M. Herlihy and N. Shavit. The Art of Multiprocessor Pro-gramming. Morgan Kaufmann Publishers Inc., 2008.
[14] M. Herlihy and J. Wing. Linearizability: a correctness con-dition for concurrent objects. TOPLAS, 12(3), 1990.
[15] M. Hoffman, O. Shalev, and N. Shavit. The baskets queue.In OPODIS. Springer, 2007.
[16] Intel. Intel 64 and ia-32 architectures software devel-oper's manual, volume 3b: System programming guide,

part 2, 2013. URL http://download.intel.com/products/processor/manual/253669.pdf.

[17] L. Lamport. Time, clocks, and the ordering of events in adistributed system. Communications ACM, 21, July 1978.
[18] M. Michael and M. Scott. Simple, fast, and practical non-blocking and blocking concurrent queue algorithms. In

PODC. ACM, 1996.
[19] H. H. Nguyen and M. Rinard. Detecting and eliminatingmemory leaks using cyclic memory allocation. In ISMM.

ACM, 2007.
[20] W. Ruan, Y. Liu, and M. Spear. Boosting timestamp-basedtransactional memory by exploiting hardware cycle counters.

In TRANSACT, 2013.
[21] P. Sewell, S. Sarkar, S. Owens, F. Z. Nardelli, and M. O.Myreen. x86-TSO: a rigorous and usable programmer's

model for x86 multiprocessors. Commun. ACM, 53(7), 2010.
[22] R. Treiber. Systems programming: Coping with parallelism.Technical Report RJ5118, IBM Almaden Research Center,

April 1986.

246